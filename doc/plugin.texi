@comment $Id: plugin.texi,v 1.7 2000/04/25 13:44:52 richi Exp $

@node Plugin Interface, Function and Type Index, Swapfile API, Top
@chapter Plugin Interface 

The plugin interface is very simple. There are actually two functions,
one to add paths to the existing plugin path list and one to query the
handle of a plugin.

@deftypefun int plugin_add_path (const char *@var{path})
This function will add @var{path} to the list of paths used to search
plugins.
@end deftypefun

@tindex plugin_t
@deftypefun {plugin_t *} plugin_get (const char *@var{name})
This function will return a handle to the plugin with the name @var{name}.
If the plugin is not already loaded it will be loaded from one of the
paths in the path list. @code{plugin_get()} returns @code{NULL} if the plugin
can't be found or an error occured during its initialization phase.
@end deftypefun

To manually add a plugin not contained in some shared library you
should call the following function.

@deftypefun {plugin_t *} plugin_add (const char *@var{name})
This function will add a new empty plugin to the database. You should
populate its database using the @code{plugin_set()} function. On success
a plugin handle is returned, @code{NULL} is returned on failure.
@end deftypefun

To access parts of the plugin the following wrapper macros should be used
on the @code{plugin_t} handle.

@tindex plugin_t
@deftypefun {const char *} plugin_name (plugin_t *@var{p})
This function returns the plugin's name.
@end deftypefun

@tindex plugin_t
@deftypefun int plugin_set (plugin_t *@var{p}, const char *@var{key}, void *@var{val})
@deftypefunx {void *} plugin_query (plugin_t *@var{p})
Using these functions you can set and query key/value pairs either stored
through dynamic library symbols or through a little per plugin database.
@code{plugin_query()} returns @code{NULL}, if there is no information about
the specified key.
@end deftypefun

To browse through all registered plugins you can use the following function.

@deftypefun {plugin_t *} plugin_next (plugin_t *@var{p})
@code{plugin_next()} gets you the next plugin in the database or the
first one if you supply @code{NULL}. @code{NULL} is returned if no
further plugins are available.
@end deftypefun


If you want to create a plugin, your dynamic object should contain the
following standard symbols with the described information attached. The
targeted subsystem may require additional defined symbols. Please refer
to the subsystems' documentation for information about those symbol
names and required contents. You should substitute the plugins name for
the @code{plugin} prefix of the symbols to prevent symbol name clashes.

@table @code
@item plugin_register
A function of type @code{(int (*)(plugin_t *p))} which does everything
necessary to register anything in the plugin to any subsystem.
@end table
