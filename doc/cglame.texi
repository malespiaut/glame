@comment $Id: cglame.texi,v 1.15 2001/08/03 11:25:30 richi Exp $

@node Console Frontend, Plugin Collection, Graphical Frontend, Top
@chapter Console Frontend (cglame)

@file{cglame} is GLAME's console interface. Beware! @file{cglame} is
not for whimps but for real men and women who dream in Scheme and
chomp brackets for breakfast. It's for those who want to feel the
ultimate power of GLAME. Thankfully, J. Random User won't have to dive
into the perils of @file{cglame} and will be all happy with @file{glame},
the friendly and intuitive graphical frontend @pxref{Graphical Frontend}.

Still there? Wheee, you're a tough one! Let's see what's in here for you:
This chapter starts with a brief introduction into the @file{cglame} user
interface. Afterwards, the wrapped midlayer and backend APIs are listed, and
an the scheme level API on top will be described.

@strong{WARNING:} this part of the documentation is absolutely not up
to date. For the time being refer to the sources - @code{src/glmid/glscript_*}
files for the glame subsystem wrappers, @code{src/glmid/glame.scm} for some
useful highlevel stuff and @code{src/gui/...} for wrappers to some of the
gui stuff (most useful for creating custom keybindings).

@menu
* cglame Introduction::
* Wrapped API::
* cglame Convenience::
@end menu


@node cglame Introduction, Wrapped API,, Console Frontend
@section cglame Introduction

@file{cglame} is a scripting engine
in the sense that you are presented a @code{guile>} command line prompt
where you can enter scheme expressions. @file{cglame} exposes GLAME's 
midlayer API and the backend API via scheme wrappers. Extra convenience
scripting procedures are defined in the global @file{glame.scm} scheme
file. You can add customisations via your @file{~/.glame.scm} file.

As command line option to @file{cglame} you may specify the
@code{swapfile} to be used. A swapfile is necessary if you want to use any
of the swapfile API procedures. Once started, @file{cglame} presents you with
a command prompt where you can evaluate scheme expressions. An example
session is shown below.

@example
$ cglame

    CGLAME for GLAME version 0.5.1, Copyright (C) 1999-2001
    Alexander Ehlert, Richard Guenther, Johannes Hirche, Daniel Kobras.
    CGLAME and GLAME come with ABSOLUTELY NO WARRANTY. This is free
    software, and you are welcome to redistribute it under certain
    conditions.

    Usage: cglame [swapfile]

Quick help:
(quit) gets you out of here.
(help) gets you some additional help.

guile> (play "/var/tmp/short.wav")
guile> (play-eff "/var/tmp/test.wav" '("echo"))
guile> (let* ((net (net-new))
... (nodes (net-add-nodes net '("read_file" "echo" "audio_out")))
... (echo2 (net-add-node net "echo")))
... (node-set-param (car nodes) "filename" "/var/tmp/test.wav")
... (nodes-connect nodes)
... (nodes-connect (list (car nodes) echo2 (caddr nodes)))
... (net-run net))
guile> (quit)
$
@end example

All used scheme procedures which are not documented in the following
sections reside in the @code{glame.scm} file shipped with glame.



@node Wrapped API, cglame Convenience, cglame Introduction, Console Frontend
@section Wrapped API

For description of the detailled semantics of the available parts of the
APIs please refer to the native documentation. Note that all scheme
procedures either throw exceptions or evaluate to @code{#f} if there is
any error.  C functions which return 0 on success are transformed to
procedures evaluating to @code{#t} on success or @code{#f} on error if
not using exceptions. Void functions generally evaluate to
@code{#unspecified}.

Note that this part of the documentation is incomplete. You can
consider the Filter API, Plugin API and Swapfile API part up to date.

@menu
* Scheme Filter API::
* Scheme Swapfile API::
* Scheme Plugin API::
* Scheme GPSM API::
* Scheme GUI interaction::
@end menu

@node Scheme Filter API, Scheme Swapfile API,, Wrapped API
@subsection Scheme Filter API

The basic filter subsystem types, @code{filter_t}, @code{filter_port_t},
@code{filter_pipe_t} and @code{filter_param_t} exist as native scheme
types and such can be type checked.

@deftypefun ( filter? obj )
@deftypefunx ( port? obj )
@deftypefunx ( pipe? obj )
@deftypefunx ( param? obj )
These procedures check @code{obj} for being of the specified type and
evaluate to @code{#t} if this is the case and @code{#f} otherwise.
@end deftypefun

Out of a filter object you can get information and subobjects using
the following procedures:

@deftypefun ( filter-name filter )
@deftypefunx ( filter-nodes filter )
@deftypefunx ( filter-ports filter )
@deftypefunx ( filter-params filter )
These procedures evaluate to a string containing the filters name or
to lists of the specified object type representing the actual subobjects
associated with the filter.
@end deftypefun

Out of a port object you can get information and subobjects using
the following procedures:

@deftypefun ( port-label port )
@deftypefunx ( port-pipes port )
@deftypefunx ( port-params port )
These procedures evaluate to a string containing the ports label or
to lists of the specified object type representing the actual subobjects
associated with the port.
@end deftypefun

Out of a param object you can get and modify information using the following
procedures:

@deftypefun ( param-label param )
@deftypefunx ( param-value param )
@deftypefunx ( param-set! param value )
These procedures evaluate to a string containing the label of the
param object, the actual value of the param whose type depends on
the param objects type or a boolean denoting the success of a param
set command.
@end deftypefun

Out of a pipe object you can get information and subobjects using
the following procedures:

@deftypefun ( pipe-samplerate pipe )
@deftypefunx ( pipe-position pipe )
@deftypefunx ( pipe-source-params pipe )
@deftypefunx ( pipe-dest-params pipe )
These procedures evaluate to an exact number containing the samplerate
of the data flowing through the pipe, a number containing the position
of the audio stream or
to lists of the specified object type representing the actual subobjects
associated with the pipe.
@end deftypefun

Pipe objects can be queried for the actual protocol type using the
following procedures:

@deftypefun ( pipe-sample? pipe )
@deftypefunx ( pipe-fft? pipe )
@deftypefunx ( pipe-ssp? pipe )
These procedures check @code{pipe} for being of the specified protocol type and
evaluate to @code{#t} if this is the case and @code{#f} otherwise.
@end deftypefun

Usually you can attach key/value pairs to a per object database. Those
object properties can be queried and modified using the following generic
interface:

@deftypefun ( set-property! obj key value )
@deftypefunx ( get-property obj key )
These procedures evaluate to @code{#unspecified} or a string object
containing the value associated with the specified key or @code{#f} if
this key has no associated value. Note that for both @code{key} and
@code{value} only string objects are allowed.
Predefined key values are @code{FILTERPARAM_DESCRIPTION},
@code{FILTERPARAM_GLADEXML} and @code{FILTERPORT_DESCRIPTION}.
@end deftypefun


The following procedures handle object serialization and creation
and destruction of objects.

@deftypefun ( filter-new [filter|plugin] )
@deftypefunx ( filter-delete filter )
@deftypefunx ( port-delete port )
@deftypefunx ( param-delete param )
@deftypefunx ( pipe-delete pipe )
@code{filter-new} constructs a new filter object by either cloning
from a filter or a plugin object or creating an empty network from
scratch. The delete procedures destruct the specified objects.
@end deftypefun

@deftypefun ( filter->string filter )
@deftypefunx ( param->string param )
While the first procedure returns a string containing a scheme
expression being able to recreate the filter object, the second
procedure just evaluates to a string containing the value of the
specified param.
@end deftypefun

@deftypefun ( filter-add-node filter filter node-name )
@deftypefunx ( filter-connect filter port-name filter port-name )
@code{filter-add-node} adds the specified filter (second parameter) to
the specified network (first parameter) using the identifier specified
as third parameter.
@code{filter-connect} connects the two specified parameters via the
specified ports identified by their port names. @code{filter-connect}
evaluates to a pipe object.
@end deftypefun

@deftypefun ( filternetwork-add-input filter filter port-name name description )
@deftypefunx ( filternetwork-add-output filter filter port-name name description )
@deftypefunx ( filternetwork-add-param filter filter param-name name description )
Procedures to be used for exporting ports and params to the outside world
in a macro filter. The first parameter is the actual network, the second
parameter is the node that gets exported from. These procedures evaluate
to a port or a param object.
@end deftypefun

@deftypefun ( glame_create_plugin filter name )
@deftypefunx ( glame_plugin_define filter name )
@code{glame_create_plugin} creates and registers a new plugin using the
specified name and associate it with the provided filter. Evaluates to a
plugin or to @code{#f} on error.
@code{glame_plugin_define} is used internally for transparently registering
or filter loading.
@end deftypefun

@deftypefun ( filter-launch filter )
@deftypefunx ( filter-start filter )
@deftypefunx ( filter-pause filter )
@deftypefunx ( filter-wait filter )
@deftypefunx ( filter-terminate filter )
These procedures handle filter network execution.
@end deftypefun



@node Scheme Swapfile API, Scheme Plugin API, Scheme Filter API, Wrapped API
@subsection Scheme Swapfile API

The swapfile is a container for data in its raw form. It is modeled
after a simple filesystem with a flat namespace (no directories) and
names being just cardinal numbers.


@deftypefun ( swapfile-open path )
@deftypefunx ( swapfile-close )
@deftypefunx ( swapfile-creat path )
These procedures control the swapfile subsystem. @code{swapfile-open}
initializes the subsystem from the swapfile at the specified location.
@code{swapfile-creat} tries to create a new swapfile at the specified
location, @code{swapfile-close} cleans up and closes the subsystem.
@end deftypefun

@deftypefun ( swdir? dir )
@deftypefunx ( sw-opendir )
@deftypefunx ( sw-readdir dir )
@deftypefunx ( sw-closedir dir )
These procedures can be used to traverse the swapfile files. Function
is like the libc readdir routines, but as the swapfile has a flat
namespace you dont specify a subdirectory for @code{sw-opendir}.
@code{sw-opendir} evaluates to a @code{swdir} object.
@code{sw-readdir} returns swapfile filenames as long as they are
available and @code{#f} upon directory end.
@end deftypefun

@deftypefun ( sw-unlink name )
Unlinks the specified file from the swapfile. You cannot recover
unlinked swapfiles. Behavior is like unlink(2), i.e. if the file
is still open the deletion of the data is postponed until close of
the file.
@end deftypefun

@deftypefun ( swfd? fd )
@deftypefunx ( sw-open name flags )
@deftypefunx ( sw-close fd )
For working with a swapfile you need to obtain a handle to it.
Use @code{sw-open} to open the swapfile with the specified name.
The flags argument is modeled after open(2), @code{O_CREAT},
@code{O_EXCL}, @code{O_TRUNC}, @code{O_RDWR}, @code{O_RDONLY}
and @code{O_WRONLY} are available. Or them together like
@code{(+ O_CREAT O_TRUNC O_RDWR)}. @code{sw-open} evaluates
to a file descriptor which you can identify using the @code{swfd?}
predicate. Use @code{sw-close} if you are finished with the file.
@end deftypefun

@deftypefun ( sw-fstat fd )
@code{sw-fstat} obtains information about an open filedescriptor.
It evaluates to a list of the form @code{( name size mode offset
cluster-start cluster-end cluster-size )} where all entries are
cardinals.
@end deftypefun

@deftypefun ( sw-lseek fd offset whence )
To seek inside a file use @code{sw-lseek} which works like lseek(2),
i.e. it seeks relative to whence offset bytes. For whence @code{SEEK_CUR},
@code{SEEK_SET} and @code{SEEK_END} are available. @code{sw-lseek}
evaluates to the current file pointer position.
@end deftypefun

@deftypefun ( sw-ftruncate fd size )
@code{sw-ftruncate} truncates the specified file to the specified size
appending zeroes in case of enlarging.
@end deftypefun

@deftypefun ( sw-sendfile dest-fd source-fd size [flags] )
@code{sw-sendfile} copies (by using copy on write) size bytes
from the current filepointer position of the source-fd to the
current filepointer position of the dest-fd. Via the optional
flags argument you can specify the following
@table @code
@item SWSENDFILE_INSERT
The data is inserted at the filepointer position of the dest-fd
instead of overwriting and/or extending the file.
@item SWSENDFILE_CUT
The data is removed from the source-fd after writing to the
dest-fd
@end table
For both files you can specify @code{SW_NOFILE} if it makes sense
(i.e. for just cutting out data specify @code{SW_NOFILE} as dest-fd
and @code{SWSENDFILE_CUT} as flag).
@end deftypefun


@deftypefun ( sw-read-floatvec fd size )
@deftypefunx ( sw-read-string fd size )
@deftypefunx ( sw-write fd data )
Those are the basic read and write operations. Both strings and
float vectors are supported by the scheme interface. For reading
you need to specify the type via the procedure name, for writing
the type is automatically determined. The read procedures read
size number of objects from the current filepointer position.
They evaluate to the number of objects read. @code{sw-write}
writes the whole object to the current filepointer position and
evaluates to the number of objects written.
All procedures increment the filepointer position by the number
of bytes read/written.
@end deftypefun



@node Scheme Plugin API, Scheme GPSM API, Scheme Swapfile API, Wrapped API
@subsection Scheme Plugin API

The glame plugin midlayer API is wrapped with the following
procedures:

@deftypefun ( plugin? plugin )
This procedure checks, if the specified object represents a plugin and
evaluates to @code{#t} in this case, else @code{#f}.
@end deftypefun

@deftypefun ( plugin-add-path path )
This procedure adds the specified path to the plugin shared object
search path that is used by the @code{plugin-get} procedure.
@end deftypefun

@deftypefun ( plugin-get name )
Queries a plugin with the specified name out of the plugin database.
Evaluates to a plugin or @code{#f} if a plugin with the specified name
cannot be found.
@end deftypefun

@deftypefun ( plugin-name plugin )
@deftypefunx ( plugin-query plugin key )
@deftypefunx ( plugin-set! plugin key value )
Queries the name or custom properties out of a plugin. Those procedures
evaluate to a string, @code{plugin-set!} sets the specified property to
the specified string. Predefined property keys are
@code{PLUGIN_DESCRIPTION}, @code{PLUGIN_PIXMAP}, @code{PLUGIN_CATEGORY},
@code{PLUGIN_GUI_HELP_PATH} and @code{PLUGIN_LABEL}.
@end deftypefun




@node Scheme GPSM API, Scheme GUI interaction, Scheme Plugin API, Wrapped API
@subsection Scheme GPSM API

The glame gpsm midlayer API is wrapped with the following
procedures:

FIXME. See @code{src/glmid/glscript_gpsm.c}.

@node Scheme GUI interaction, , Scheme GPSM API, Wrapped API
@subsection Scheme GUI interaction

FIXME. See various files in @code{src/gui}.


@node cglame Convenience,, Wrapped API, Console Frontend
@section cglame Convenience

For the convenience procedures online help is (maybe) available
via @code{(help command)} or @code{(help)}.

@menu
* Network setup::
* Cooked operations::
@end menu

@node Network setup, Cooked operations,, cglame Convenience
@subsection Network setup

@deftypefun ( net-new )
Creates a new filternetwork. @code{net-new} evaluates to a
filter.
@end deftypefun

@deftypefun ( net-add-node filter node '("label" value) ... )
@deftypefunx ( net-add-nodes filter node '(node '("label" value) ...) ... )
@deftypefunx ( nodes-delete filter ... )
@code{net-add-node} adds a single node with optional parameters
to the network specified by @var{filter}. @code{net-add-nodes}
adds a set of nodes with optional parameters to the network.
@code{net-add-node} evaluates to a @code{filter}, @code{net-add-nodes}
to a list of @code{filter}s. Using @code{nodes-delete} you can delete
nodes from a network.
@end deftypefun

@deftypefun ( nodes-connect nodes ... )
@code{nodes-connect} linearily connects the specified lists of
@code{filter}s.
@end deftypefun

@deftypefun ( node-set-params filter '("label" value) ... )
Using @code{node-set-params} you can set the parameters of the
specified @var{filter}.
@end deftypefun

@deftypefun ( net-run filter )
@deftypefunx ( net-run-bg filter )
@code{net-run} starts processing of the network and waits until completion.
@code{net-run-bg} starts processing of the network and returns immediately.
@end deftypefun


@node Cooked operations,, Network setup, cglame Convenience
@subsection Cooked operations

The following procedures can be customised by setting
@code{audio-out}, @code{read-file} or @code{write-file} to other
filters than their default ones like @code{(set! read-file "read-mp3")}.

@deftypefun ( play filename )
Plays the specified file.
@end deftypefun

@deftypefun ( play-eff filename '(effect ("label" value) ...) ... )
@deftypefunx ( save-eff infile outfile '(effect ("label" value) ...) ... )
Plays or saves the specified file after applying the specified chain
of effects with parameters.
@end deftypefun

