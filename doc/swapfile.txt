				SWAPFILE - Documentation
				========================

NOTE: Do not read the source! You will probably not understand a
      thing what is happening - you may even get blind! You have been
      warned. 

NOTE2: Though the code is not easy to read, the API will not change until
       after release 1.0

If you have any questions regarding to the covered (or uncovered but
related) topics in this document, please insert lines like "Q: I dont
understand what you mean by read-only."  if you have permissions to do
so, or quote the questionable part of this document and send the
questions per e-mail to richi@glame.sourceforge.net



Introduction
------------

This is the documentation for the swapfile subsystem of the GNU/Linux Audio
Mechanics program. Swapfile was designed not specifically for GLAME but with
the idea of storing of and operating on audio streams.

Swapfile provides a store for multiple independend sets of (not necessarily)
onedimensional data. Swapfile supports transparent and unlimited undo and redo
of cut- and insert-like operations.

A set of data in swapfile is generally refered to as a "file". Each such file
is internally split up into so called "fileclusters" who determine the
granularity of access to the files contents.

A file can be in two states, which results from the fact that not all
operations on a file are logged, i.e. can be undone and redone. The two states
are basically read-only and read-write. On a file in read-only state you may
only start logged operations, on a read-write file you may do everything. The
states get switched as soon as there are pending or finished logged operations
on the file.

While this may sound terribly lowering the use of swapfile, it greatly
simplifies and speeds up operations and reduces necessary storage by an amount
you wouldnt believe.



The swapfile API
----------------

So lets just jump into listing the functions of the swapfile API and
documenting the semantics.

To initialize the swapfile subsystem you have to open an existing swapfile
which in turn you may create using the gmkswap utility. After finishing
operation you should close it again. Use the following functions:

     int swap_open(char *name, int flags);

     swap_open opens the swapfile with the specified name and the specified
     flags (no flags are defined yet, use 0). Returns -1 if it was not
     possible to open the swapfile or the swapfile is in an inconsistent
     state.

     void swap_close();

     swap_close closes the swapfile and updates the metadata state of the
     disk version of the swapfile. This puts the swapfile into a consistent
     state.


To allocate and free files in a swapfile there exist two functions - well
actually there are three, but the last one is less generic as it will turn your
file into read-only state.

     fileid_t file_alloc(off_t size);

     file_alloc does allocate a new file of the provided size. The return value
     is a handle for all subsequent operations on the file, -1 is returned on
     error. The contents of the file are initially set to zero and its state
     will be read-write after the operation.

     void file_unref(fileid_t fid);

     file_unref drops the file identified with fid and all its data. This
     operation is not logged and in turn cannot be undone. file_unref accepts
     files in both states, read-only and read-write.

Another set of two functions lets you change and query the size of a file.

     int file_truncate(fileid_t fid, off_t size);

     file_truncate takes a file in read-write state and truncates its size to
     size, just like the ftruncate call does with regular unix-files.
     If size is less than the current size of the file, all data after and
     including position size will be discarded.
     If size is greater than the current size of the file, subsequently
     allocated data is initially set to zero.
     file_truncate is not logged, i.e. you cannot undo this operation. The
     state of the file does not change from read-write. file_truncate will
     return 0 on success or -1 on error in which case file is not modified at
     all.

     off_t file_size(fileid_t fid);

     file_size returns the size of file identified with fid or -1 if no such
     file exists. The state of the file does not matter, neither is it changed
     by file_size as is the file itself.

As mentioned above, there is another way to create a new file. This is by
copying an existing file or a part of it.

     fileid_t file_copy(fileid_t fid, off_t pos, off_t size);

     file_copy will generate a new file containing the contents in the interval
     [pos, pos+size[ of the old file as _REFERENCE_ - i.e. no additional
     storage is required for this operation. This has the downside that both
     files, the source and the destination are switched to state read-only
     (the initial state of the source file does not matter).
     The identifier of the copy is returned, or -1 on error. It is illegal to
     specify an interval not entirely contained in the source file.

The following operations allow direct access to the files data either for
reading (read-only state) or reading and writing (read-write state). All access
goes through fileclusters (see introduction). To access parts of the file data
you first have to get the corresponding filecluster, then mmap it and finally
munmap it. The functions are

     filecluster_t *filecluster_get(fileid_t fid, off_t pos);

     filecluster_get will return the filecluster containing the position pos of
     the file identified with fid. It is illegal to specify a position outside
     of the file or an unexisting one, NULL is returned in these cases.

     filecluster_start(filecluster_t *fc);
     filecluster_end(filecluster_t *fc);
     filecluster_size(filecluster_t *fc);

     filecluster_start returns the position of the first contained datum,
     filecluster_end returns the position of the last contained datum and
     filecluster_size will return the size of the contained data in bytes.

     filecluster_next(fc);
     filecluster_prev(fc);

     filecluster_next and filecluster_prev let you traverse the fileclusters
     of a file, both may return NULL if you hit the end or the start of the
     file. It is always true for the first filecluster of a file to have
     filecluster_start(fc) == 0, for the last filecluster of a file to have
     filecluster_end(fc) == file_size(fid) and for each pair of following
     fileclusters filecluster_end(prev)+1 == filecluster_start(next).


     char *filecluster_mmap(filecluster_t *fc);

     filecluster_mmap will mmap the data contained in the filecluster and
     return a pointer to it. The mmapped memory area is write-protected, if the
     file of the filecluster is in read-only state (so you will get a SIGSEGV
     if you try to write into it). Note that it is illegal to access parts of
     the mmapped area not within the fileclusters size.  Caveat emptor!
     filecluster_mmap may change the size of the filecluster! So if you want to
     have access to position pos in the file f you may have to do
	fc = filecluster_get(f, pos);
        mem = filecluster_mmap(fc);
	while (pos > filecluster_end(fc)) {
	      filecluster_munmap(fc);
	      fc = filecluster_next(fc);
	      mem = filecluster_mmap(fc);
	} 

     void filecluster_munmap(filecluster_t *fc);

     munmaps a previously mmapped filecluster. It is illegal to munmap a
     filecluster more times than it has been mmapped.


Now for the logged operations. All those operations have to be grouped into a
transaction of one or more operation. Such a transaction can be undone and
subsequently redone.

To start and end a transaction you have to use the following two functions.

     int file_transaction_begin(fileid_t fid);
     int file_transaction_end(fileid_t fid);

     file_transaction_begin will start a new transaction for the file fid,
     file_transaction_end will end it. Nested begin/end calls are allowed.
     Both operations return 0 on success and -1 on error.

     int file_transaction_undo(fileid_t fid);
     int file_transaction_redo(fileid_t fid);

     file_transaction_undo will try to undo the last completed transaction of
     the file fid, file_transaction_redo will try to redo the last undone
     transaction of the file. It is illegal to undo a transaction currently in
     progress, you have first to end it. Note that all redo-records of a file
     are discarded once you begin a new transaction on this file.

The operations that can be undone and redone are the following ones - you may
miss some operations commonly used, but you may notice that you can compose any
standard operation with the following two logged operation and the (not
logged!) operation file_copy (see above).

     int file_op_insert(fileid_t fid, off_t pos, fileid_t file);

     file_op_insert will insert the file file into the file fid at position
     pos. pos has to be in the range of 0..file_size(fid), else the operation
     fails. Both files will change its state to read-only and you may not any
     longer access the inserted file file - all subsequent operations on it
     will fail and set errno to ENOENT. If this operation is undone, the
     inserted file will become accessible again.
     file_op_insert will return 0 on success and -1 on error.

     int file_op_cut(fileid_t fid, off_t pos, off_t size);

     file_op_cut will cut the interval [pos..pos+size[ out of the file fid.
     The interval has to be entirely contained in fid. The file will change
     its state to read-only.
     file_op_cut will return 0 on success and -1 on error.

The common cut&paste operations can be composed as follows:
     copy: file_copy()
     paste: file_op_insert() or file_copy() & file_op_insert() for multiple
            pastes
     cut: file_copy() & file_op_cut()
     delete: file_op_cut()



The semantics of the following function are not yet fully defined, it was added
to support the swapfile_info tool.

     fileid_t file_next(fileid_t fid);

     file_next will return the next file identifier after fid or the first one,
     if fid is -1. -1 is returned if no further file does exist.
     Be careful! At the moment you do not get a valid reference to the file,
     i.e. you may not operate on it in any way! So this function is essentially
     useless at the moment.
