@comment $Id: filter.texi,v 1.24 2000/12/07 14:24:39 richi Exp $

@node Filter API, Filter Tutorial, Plugin Collection, Top
@chapter Filter API

@table @strong
@item NOTE
This is not a guide on filter programming! Look for this in the filter
tutorial (@pxref{Filter Tutorial}).
@end table

The filter subsystem has three independent APIs, one for the filter registry,
one for filter programming and one for using the filters and connecting them
to so called filter networks.

If you have any questions related to this document, please quote the 
relevant lines and send your comments per e-mail to
@email{glame-devel@@glame.sourceforge.net} (c/o richi).

@menu
* Introducing the Filter Subsystem::
* The Filter Objects::
* The Filter Programming API::
* The Filter Network API::
@end menu

@node Introducing the Filter Subsystem, The Filter Objects, , Filter API
@section Introducing the Filter Subsystem

The filter subsystem introduces the concepts of filters and networks of
filters. The basic idea is to have streams transporting arbitrary data
with attached properties floating through a network. This network comprises 
of so called @dfn{filters} which are connected to each other through
@dfn{filter pipes}. The filters may modify the data in the streams
and its properties. A filter can even merge two or more streams into
one stream or split one stream into any number of streams containing the
same data and the same properties by reference.
To tune the operations on the stream each filter may be assigned a
number of parameters. Each filter pipe can be assigned a number of parameters
at both ends, too.

The API from the design philosophy standpoint is a cloning objects
out of another one. There is one main object, the @code{filter_t}
which contains @code{filter_port_t}s through which filters get
connected using @code{filter_pipe_t}s. A @code{filter_t} can be
used both as container for other filters and as working part of another
group of filters, called filter network.
This means that you can set up a network of filters, and in turn convert this
filter network into an abstract filter which you can use in another filter
network by instantiating it.


@node The Filter Objects, The Filter Programming API, Introducing the Filter Subsystem, Filter API
@section The Filter Objects

@menu
* The Filter Object::
* Basics on Databases::
* The Filter Parameter Object::
* The Filter Port Object::
* The Filter Pipe Object::
@end menu


@node The Filter Object, Basics on Databases, , The Filter Objects
@subsection The Filter Object

The @code{filter_t} object represents an instance of a filter. A filter
generally consists of a set of ports, parameters and child filters. Filters
on the same level in the hierarchy may be connected using pipes. Filters
are accessible to the user as plugins as soon as they are registered as
such. Plugins are used as reference instances from which actual filters
are cloned.

The following functions, often implemented using macros, are available
to obtain parts of the @code{filter_t} object.

@tindex filter_paramdb_t
@deftypefun {filter_paramdb_t *} filter_paramdb (filter_t *@var{f})
Using this function you get access to the filters parameter database.
You will need it to add, remove or query filter parameters using the
API provided by the filter parameter subsystem.
@end deftypefun

@tindex filter_portdb_t
@deftypefun {filter_portdb_t *} filter_portdb (filter_t *@var{f})
Using this function you get access to the filters port database.
You will need it to add, remove or query filter ports using the API
provided by the filter port subsystem.
@end deftypefun

@tindex glsig_emitter_t
@deftypefun {glsig_emitter_t *} filter_emitter (filter_t *@var{f})
Using this function you get access to the filter scope signal emitter.
Through this emitter you can receive signals sent out by the components
of this filter. You can use the glame signal API to register signal
handlers.
@end deftypefun

@deftypefun int filter_nrnodes (filter_t *@var{f})
Use this function to obtain the number of child filters associated
with the filter @var{f}.
@end deftypefun


A filter in a set of connected filters may be in an inconsistent
state, so an error number and string are provided to notify the outer
world. Also macros to set and query this state are provided.

@deftypefun int filter_errno (filter_t *@var{f})
The filter error number returned by this function represents the
actual state of the filter and is usually zero which means no error.
For more information refer to the @code{filter_errstr()} function.
@end deftypefun

@deftypefun {const char *} filter_errstr (filter_t *@var{f})
Using this function you get access to a human readable error string
of the filter.
@end deftypefun

@deftypefun int filter_has_error (filter_t *@var{f})
If this function returns a non-zero value the filter is in an
inconsistent state.
@end deftypefun

@deftypefun void filter_set_error (filter_t *@var{f}, const char *@var{msg})
Flags the filter with an error and the message @var{msg}.
@end deftypefun

@deftypefun void filter_clear_error (filter_t *@var{f})
Clears a previously set error condition and marks the filter as
in a consistent state.
@end deftypefun


To query the role of a filter in a simple manner the following macros
will help you. Others are defined, but the ones mentioned here are
the only ones you are supposed to use.

@deftypefun int FILTER_IS_PLUGIN (filter_t *@var{f})
Returns a non-zero value, if this filter instance is registered as
a plugin.
@end deftypefun

@deftypefun int FILTER_IS_PART_OF_NETWORK (filter_t *@var{f})
Returns a non-zero value, if this filter instance is a child of another
filter instance.
@end deftypefun

@deftypefun int FILTER_IS_NETWORK (filter_t *@var{f})
Returns a non-zero value, if this filter instance has childs.
@end deftypefun


To actually create a filter instance, to delete such or register
it as a plugin the following functions are provided.

@tindex filter_t
@deftypefun {filter_t *} filter_creat (filter_t *@var{template})
To create a new filter instance either the existing instance @var{template}
is cloned, or in case @code{NULL} is provided a minimal one is created
from scratch. The new filter instance is returned on success, @code{NULL}
on error.
@end deftypefun

@tindex filter_t
@tindex plugin_t
@deftypefun {filter_t *} filter_instantiate (plugin_t *@var{p})
The other way to create a new filter instance is to instantiate a
previously registered filter instance -- a plugin. The new filter
instance is returned on success, @code{NULL} on error.
@end deftypefun

@tindex filter_t
@deftypefun void filter_delete (filter_t *@var{f})
This function deletes a filter instance and all its sub-objects such
as ports, parameters, pipes and child filters.
@end deftypefun

@tindex filter_t
@tindex plugin_t
@deftypefun int filter_register (filter_t *@var{f}, plugint_t *@var{p})
This function tries to associate the given filter instance with the
provided plugin. On success, zero is returned, -1 on error.
@end deftypefun


@tindex filter_t
@deftypefun {char *} filter_to_string (filter_t *@var{f})
@code{filter_to_string()} saves the current state of the filter
into a string and returns a pointer to it. NULL is returned on
error. You have to @code{free()} the returned string later. Use this
function to save and potentially recreate a constructed network of
which this filter is the container. The string representation is
executable scheme code.
@end deftypefun



@node Basics on Databases, The Filter Parameter Object, The Filter Object, The Filter Objects
@subsection Basics on Databases

Both filter ports and filter parameters are organized using databases which
can store arbitrary key/object pairs. Keys have to be unique strings and
objects can be queried specifying the right key. Also usually an iterator
is provided to iterate through all items in the database.

All databases are homogenly typed, i.e. only one kind of object can be
stored in a database. For each such special database a database type
exists (@code{filterparamdb_t} and @code{filterportdb_t}) with the
corresponding object types (@code{filter_param_t} and @code{filter_port_t}).

In addition to these first class object databases there are databases
which store strings -- the property databases which exist in each of
@code{plugin_t}, @code{filter_param_t} and @code{filter_port_t}.

The external visible API of a generic database is the following (see
the @file{src/hash/gldb.h} file):

@tindex gldb_t
@deftypefun void gldb_init (gldb_t *@var{db})
@deftypefunx void gldb_delete (gldb_t *@var{db})
@deftypefunx int gldb_copy (gldb_t *@var{dest}, gldb_t *@var{source})
@deftypefunx int gldb_nritems (gldb_t *@var{db})
These function operate on a whole database, respectively initialize
an empty database, deletes all items of a database, copies all items
from one database to another and tells about the number of items
in the database.
@end deftypefun

@tindex gldb_item_t
@deftypefun void gldb_init_item (gldb_item_t *@var{item})
@deftypefunx void gldb_delete_item (gldb_item_t *@var{item})
@deftypefunx {gldb_item_t *} gldb_copy_item (gldb_item_t *@var{item})
These functions operate on a database item, respectively initializing
it, deleting it or creating a copy of it.
@end deftypefun

@tindex gldb_t
@tindex gldb_item_t
@deftypefun int gldb_add_item (gldb_t *@var{db}, gldb_item_t *@var{item}, const char *@var{label})
@deftypefunx void gldb_remove_item (gldb_item_t *@var{item})
@deftypefunx {gldb_item_t *} gldb_query_item (gldb_t *@var{db}, const char *@var{label})
These functions can be used to add an item with the specified label to the
database, remove it out of the database, or to query a database item by
specifying the label that was given at addition time.
@end deftypefun

@deftypefn Iterator {} gldb_foreach_item (gldb_t *@var{db}, gldb_item_t *@var{item}) @{ @}
Using this iterator you can iterate through all items stored in the
specified database. You may not remove items while iterating, though.
@end deftypefn

For information about the internal operation of the glame database
framework and how to create new databases for a special object you are
referred to the actual headerfiles and the documentation contained
therein.



@node The Filter Parameter Object, The Filter Port Object, Basics on Databases, The Filter Objects
@subsection The Filter Parameter Object

The @code{filter_param_t} object defines and contains a parameter used
at the filter and the filter pipe scope. To access parts of its structure
the following functions are provided.

@tindex filter_param_t
@deftypefun {const char *} filterparam_label (filter_param_t *@var{param})
Access the parameters label as used in the database.
@end deftypefun

@tindex filter_param_t
@tindex filter_t
@deftypefun filter_t filterparam_filter (filter_param_t *@var{param})
Access the filter the parameter or its pipe is attached to.
@end deftypefun

@tindex filter_pipe_t
@tindex filter_param_t
@deftypefun {filter_pipe_t *} filterparam_get_sourcepipe (filter_param_t *@var{param})
@deftypefunx {filter_pipe_t *} filterparam_get_destpipe (filter_param_t *@var{param})
If you know that the parameter is attached to a database embedded into a
filter pipe and you even know the end to which it is attached, you may
use this functions to get access to this pipe.
@end deftypefun

@tindex filter_param_t
@deftypefun int filterparam_type (filter_param_t *@var{param})
Query the type of the parameter.
@end deftypefun

@tindex filter_param_t
@deftypefun {void *} filterparam_val (filter_param_t *@var{param})
Get a generic pointer to the actual value of the parameter.
@end deftypefun

To access a parameter value of a specified type the following
helpers are provided. First check the actual type of the parameter,
then use this non-typechecking functions.

@tindex filter_param_t
@deftypefun int filterparam_val_int (filter_param_t *@var{param})
Get the integer value of an integer typed parameter.
@end deftypefun

@tindex filter_param_t
@deftypefun {const char *} filterparam_val_string (filter_param_t *@var{param})
Get the string value of a string typed parameter.
@end deftypefun

@tindex filter_param_t
@deftypefun float filterparam_val_float (filter_param_t *@var{param})
Get the float value of a float typed parameter.
@end deftypefun

@tindex filter_param_t
@deftypefun SAMPLE filterparam_val_sample (filter_param_t *@var{param})
Get the SAMPLE value of a SAMPLE typed parameter.
@end deftypefun


As nearly every object, the filter parameter object has a property
database whose elements you may access or modify using the following
functions.

@tindex filter_param_t
@deftypefun {const char *} filterparam_get_property (filter_param_t *@var{param}, const char *@var{label})
Get the value of the property stored in the parameters property database
using the specified label.
@end deftypefun

@tindex filter_param_t
@deftypefun void filterparam_set_property (filter_param_t *@var{param}, const char *@var{label}, const char *@var{value})
Set or add the property @var{label} to the provided @var{value}.
@end deftypefun


To define parameters and to set their values the following functions
are provided.

@tindex filter_param_t
@deftypefun int filterparam_set (filter_param_t *@var{param}, const void *@var{val})
To change the value of a parameter use the following function.  Note
that on a successful change 0 is returned and a GLSIG_PARAM_CHANGED
signal is emitted. -1 is returned on an error such as memory shortage or
a rejected change by the set_param() method of the filter.
@end deftypefun

@tindex filter_param_t
@deftypefun int filterparam_set_string (filter_param_t *@var{param}, const char *@var{val})
As filterparam_set() the following function tries to set the parameters
value, but this time using the value encoded in the provided string.
@end deftypefun

@tindex filter_param_t
@deftypefun {char *} filterparam_to_string (const filter_param_t *@var{param})
To generate a string representation of the parameters value use the
following function. The returned string has to be freed by the
caller. NULL is be returned on error.
@end deftypefun

@tindex filter_param_t
@deftypefun void filterparam_delete (filter_param_t *@var{param})
Delete a parameter out of its database.
@end deftypefun

@tindex filter_param_t
@deftypefun int filterparam_redirect (filter_param_t *@var{source}, filter_param_t *@var{dest})
Redirects parameter set/query operations (by copy!) to the specified
parameter. Returns 0 on success, -1 on error.
@end deftypefun

@tindex filter_param_t
@tindex filter_paramdb_t
@deftypefun {filter_param_t *} filterparamdb_add_param (filter_paramdb_t *@var{db}, const char *@var{label}, int @var{type}, const void *@var{val}, ...)
To add a new parameter (i.e. define it) use the following function
through which you specify the parameters label, its type and its default
value (see below for some convenience wrappers). Also any number of
key/value pairs may be optionally specified and are stored into the
parameters property database.  You have to "finish" the property list by
a @code{FILTERPARAM_END} argument even if you did not specify any property.
@end deftypefun

@tindex filter_param_t
@tindex filter_paramdb_t
@deftypefun {filter_param_t *} filterparamdb_add_param_int (filter_paramdb_t *@var{db}, const char *@var{label}, int @var{type}, int @var{val}, ...)
@deftypefunx {filter_param_t *} filterparamdb_add_param_float (filter_paramdb_t *@var{db}, const char *@var{label}, int @var{type}, float @var{val}, ...)
@deftypefunx {filter_param_t *} filterparamdb_add_param_string (filter_paramdb_t *@var{db}, const char *@var{label}, int @var{type}, const char *@var{val}, ...)
To ease the use of the @code{filterparamdb_add_param()} function with respect
to specifying the default parameter value, the following wrappers are
provided which take a typed fourth parameter. Nothing else changes.
@end deftypefun

@tindex filter_param_t
@tindex filter_paramdb_t
@deftypefun {filter_param_t *} filterparamdb_get_param (filter_paramdb_t *@var{db}, const char *@var{label})
To query a parameter out of the filter parameter database use the
following function. If @code{NULL} is returned, the parameter does not
exist.
@end deftypefun

@tindex filter_paramdb_t
@deftypefun void filterparamdb_delete_param (filter_paramdb_t *@var{db}, const char *@var{label})
To delete a parameter use the following function. If the paramter does
not exist, nothing is done.
@end deftypefun

@tindex filter_paramdb_t
@tindex filter_param_t
@deftypefn Iterator {} filterparamdb_foreach_param (filter_paramdb_t *@var{db}, filter_param_t *@var{param}) @{ @}
You can iterate through all parameters of a database using the following
iterator (which acts like a for statement with the second parameter as
running variable). Note that you may not delete parameters in this loop!
@end deftypefn

@tindex filter_paramdb_t
@deftypefun int filterparamdb_nrparams (filter_paramdb_t *@var{db})
To just query the number of parameters stored in a parameter database
use the following function.
@end deftypefun



@node The Filter Port Object, The Filter Pipe Object, The Filter Parameter Object, The Filter Objects
@subsection The Filter Port Object


@tindex filter_port_t
@deftypefun {const char *} filterport_label (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@deftypefun int filterport_type (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@tindex filter_paramdb_t
@deftypefun {filter_paramdb_t *} filterport_paramdb (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@deftypefun int filterport_is_input (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@deftypefun int filterport_is_output (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@tindex glsig_emitter_t
@deftypefun {glsig_emitter_t *} filterport_emitter (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@deftypefun {filter_t *} filterport_filter (filter_port_t *@var{port})
@end deftypefun


@tindex filter_port_t
@deftypefun {const char *} filterport_get_property (filter_port_t *@var{port}, const char *@var{label})
@end deftypefun

@tindex filter_port_t
@deftypefun void filterport_set_property (filter_port_t *@var{port}, const char *@var{label}, const char *@var{value})
@end deftypefun

@tindex filter_port_t
@deftypefun int filterport_nrpipes (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@deftypefun {filter_pipe_t *} filterport_get_pipe (filter_port_t *@var{port})
@end deftypefun

@tindex filter_port_t
@deftypefun {filter_pipe_t *} filterport_next_pipe (filter_port_t *@var{port}, filter_pipe_t *@var{pipe})
@end deftypefun

@tindex filter_port_t
@deftypefn Iterator filterport_foreach_pipe (filter_port_t *@var{port}, filter_pipe_t *@var{pipe}) @{ @}
@end deftypefn


@tindex filter_port_t
@deftypefun int filterport_redirect (filter_port_t *@var{source}, filter_port_t *@var{dest})
Redirects connections to this port to another port. Works automagically
for network filter ports. Returns -1 on error, 0 on success.
@end deftypefun

@tindex filter_port_t
@deftypefun void filterport_delete (filter_port_t *@var{port})
Delete a port out of its database.
@end deftypefun


The API which handles defining/setting/querying ports.  All this is done
using a filter port database handle, which you can get using
@code{filter_portdb()}.

@tindex filter_portdb_t
@tindex filter_port_t
@deftypefun {filter_port_t *} filterportdb_add_port (filter_portdb_t *@var{db}, const char *@var{label}, int @var{type}, int @var{flags}, ...)
To add a new port (i.e. define it) use the following function through
which you specify the port label, its type and flags. Also any number of
key/value pairs may be optionally specified and are stored into the
ports property database.  You have to "finish" the property list by a
@code{FILTERPARAM_END} argument even if you did not specify any property.
@end deftypefun

@tindex filter_portdb_t
@tindex filter_port_t
@deftypefun {filter_port_t *} filterportdb_get_port (filter_portdb_t *@var{db}, const char *@var{label})
To query a port out of the filter port database use the following
function. If @code{NULL} is returned, the port does not exist.
@end deftypefun

@tindex filter_portdb_t
@deftypefun void filterportdb_delete_port (filter_portdb_t *@var{db}, const char *@var{label})
To delete a port use the following function. If the paramter does not
exist, nothing is done.
@end deftypefun

@tindex filter_portdb_t
@tindex filter_port_t
@deftypefn Iterator filterportdb_foreach_port (filter_portdb_t *@var{db}, filter_port_t *@var{port}) @{ @}
You can iterate through all ports of a database using the following
iterator (which acts like a for statement with the second parameter as
running variable). Note that you may not delete ports in this loop!
@end deftypefn

@tindex filter_portdb_t
@deftypefun int filterportdb_nrports (filter_portdb_t *@var{db})
To just query the number of ports stored in a port database use the
following function.
@end deftypefun



@node The Filter Pipe Object, , The Filter Port Object, The Filter Objects
@subsection The Filter Pipe Object

The filter pipe object represents a connection between two filter port
objects.

@tindex filter_pipe_t
@deftypefun int filterpipe_type(filter_pipe_t *@var{pipe})
Query the pipes type.
@end deftypefun

@tindex filter_pipe_t
@deftypefun {glsig_emitter_t *} filterpipe_emitter(filter_pipe_t *@var{pipe})
Using this function you get access to the pipes signal emitter. See the
glsignal manual for instructions on what to do with this.
@end deftypefun

@tindex filter_pipe_t
@deftypefun {filter_port_t *} filterpipe_source(filter_pipe_t *@var{pipe})
Query the pipes source port.
@end deftypefun

@tindex filter_pipe_t
@deftypefun {filter_port_t *} filterpipe_dest(filter_pipe_t *@var{pipe})
Query the pipes destination port.
@end deftypefun

@tindex filter_pipe_t
@deftypefun {filter_paramdb_t *} filterpipe_sourceparamdb(filter_pipe_t *@var{pipe})
Query the parameter database attached to the source end of the pipe.
@end deftypefun

@tindex filter_pipe_t
@deftypefun {filter_paramdb_t *} fitlerpipe_destparamdb (filter_pipe_t *@var{pipe})
Query the parameter database attached to the destination end of the pipe.
@end deftypefun


@tindex filter_pipe_t
@deftypefun void filterpipe_settype_sample (filter_pipe_t *@var{pipe}, int @var{rate}, float @var{hangle})
Sets the pipe type to sample and the sample pipe properties to the
specified values.
@end deftypefun

@tindex filter_pipe_t
@deftypefun int filterpipe_sample_rate (filter_pipe_t *@var{pipe})
@deftypefunx float filterpipe_sample_hangle(filter_pipe_t *@var{pipe})
For a sample typed pipe you have to query the pipes properties using
these functions. The properties are the sample rate and the horizontal
angle of the stream.
@end deftypefun


@tindex filter_pipe_t
@deftypefun void filterpipe_settype_fft (filter_pipe_t *@var{pipe}, int @var{rate}, float @var{hangle}, int @var{bsize}, int @var{osamp})
Sets the pipes type to FFT and the FFT pipe properties to the specified
values.
@end deftypefun

@tindex filter_pipe_t
@deftypefun int filterpipe_fft_rate (filter_pipe_t *@var{pipe})
@deftypefunx float filterpipe_fft_hangle (filter_pipe_t *@var{pipe})
@deftypefunx int filterpipe_fft_bsize (filter_pipe_t *@var{pipe})
@deftypefunx int filterpipe_fft_osamp (filter_pipe_t *@var{pipe})
For an FFT typed pipe you have to query the pipes properties using
these functions. The properties are the sample rate and the horizontal
angle of the stream. The blocksize and the oversampling factor specify
the FFT.
@end deftypefun


@tindex filter_pipe_t
@deftypefun {filter_pipe_t *} filterport_connect (filter_port_t *@var{source}, filter_port_t *@var{dest})
Connect the two ports source and dest with a pipe, returns the created
pipe on success, or NULL on error.
@end deftypefun

@tindex filter_pipe_t
@deftypefun void filterpipe_delete (filter_pipe_t *@var{pipe})
Breaks a previously established connection and deletes the associated
pipe.
@end deftypefun




@node The Filter Programming API, The Filter Network API, The Filter Objects, Filter API
@section The Filter Programming API

The filter programming API consists of functions to receive, create and forward
buffers, of functions to access the connections made to the filters ports, and
of functions to get and set the filters parameters. The filter programming API
also defines the semantics of the methods provided by the filters itself as
they are used by the filter network API. The filter programming API is
designed to be thread safe.

@menu
* Filter Methods::
* Doing Real Work::
* Working on SAMPLEs::
@end menu

@node Filter Methods, Doing Real Work, , The Filter Programming API
@subsection Filter Methods

Let's start with defining the semantics of the methods a filter can provide.
All methods are stored in the 
@tindex filter_t
@code{filter_t} structure, but only the @code{f()} method is
mandatory. You have to set all other methods explicitly---sane defaults are
provided for them. To learn about semantic details you may want to look into
the file @file{src/filter/filter_network.c}, too.

@tindex filter_node_t
@deftypefn Method int f (filter_node_t *@var{n})
@code{f()} is the main method of every filter, it's the only mandatory method. 
@code{f()} does the filter work, i.e. it gets launched as thread once the
filter network starts operating. See below for what to do in this
method. You have to return -1 if you don't like anything of the setup,
which will terminate the whole network, or 0 if everything was ok and you
are finished with processing.

@findex FILTER_AFTER_INIT
@findex FILTER_DO_CLEANUP
@findex FILTER_ERROR_RETURN
@findex FILTER_ERROR_CLEANUP
@findex FILTER_CHECK_STOP
@findex FILTER_BEFORE_STOPCLEANUP
@findex FILTER_BEFORE_CLEANUP
@findex FILTER_RETURN
Required parts of the @code{f()} method are an initialization section which
must be ended by a call of the @code{FILTER_AFTER_INIT} macro and a cleanup
section which @code{FILTER_BEFORE_CLEANUP} has to precede. In the initialization
section you may not use any functions which may block on the network. You may
return -1 at any point during the initialization indicating an error. Once your
code hits @code{FILTER_AFTER_INIT}, returning 0 is mandatory though. In the
init section, use macro @code{FILTER_DO_CLEANUP} for a jump to the cleanup
section, @code{FILTER_ERROR_RETURN(const char *)} to return with an error
message set to the specified string, @code{FILTER_ERROR_CLEANUP(const char *)}
for the equivalent that quits through the cleanup section like
@code{FILTER_DO_CLEANUP}.

In the main processing loop (if there is such in your filter) you are
required to call @code{FILTER_CHECK_STOP} from time to time to check for
an abort request. If such occured processing is continued after
@code{FILTER_BEFORE_STOPCLEANUP} which should preceede
@code{FILTER_BEFORE_CLEANUP} for obvious reasons. You should in general
finish the @code{f()} method by calling @code{FILTER_RETURN} instead of
just @code{return 0;} to ensure proper return value in case of an error.

For further advise see the @ref{Filter Tutorial}.
@end deftypefn

@tindex filter_node_t
@deftypefn Method int init (filter_node_t *@var{n})
@code{init()} gets called by the @code{filternetwork_add_node()} function after allocating a
new instance of a filter (the so called filternode). You may do
anything with the private field of the filternode and attach signal
handlers to the nodes emitter, everything else is strictly
private. If you return -1 the node is deleted and @code{filternetwork_add_node()} will return an error. If everything is ok you should return 0.
@end deftypefn

@tindex filter_node_t
@tindex filter_pipe_t
@deftypefn Method int connect_out (filter_node_t *@var{source}, const char *@var{port}, filter_pipe_t *@var{p})
@code{connect_out()} is invoked by the @code{filternetwork_add_connection()} 
function.
@code{connect_out()} gets called at each connection request to an output port
but before the call to the @code{connect_in()} method of the corresponding
destination port. You may reject the connection by returning -1 or
accept it by returning 0. You should set up the pipe type and the
corresponding fields in the type-specific union using the appropriate macros.
You may modifiy the pipe's source, i.e. perform redirections---but be careful.
After the connection has been created a @code{GLSIG_PIPE_CHANGED} signal is
raised on the new pipe.
@end deftypefn

@tindex filter_node_t
@tindex filter_pipe_t
@deftypefn Method int connect_in (filter_node_t *@var{dest}, const char *@var{port}, filter_pipe_t *@var{p})
@code{connect_in()} is like @code{connect_out()} but gets called after the 
@code{connect_out()}
call, and you don't have to set up any type specific information in the
filter pipe @var{p}. Just return -1 if you don't like the connection. 
Otherwise return 0. Redirections of the destination may be done under the
same conditions as in @code{connect_out()}. After the connection has been
created a @code{GLSIG_PIPE_CHANGED} signal is raised on the new pipe.
@end deftypefn

@tindex filter_node_t
@tindex filter_param_t
@deftypefn Method int set_param (filter_node_t *@var{dest}, filter_param_t *@var{p}, const void *@var{val})
The @code{set_param()} method can be used to check a value which is to be
setted against some conditions. The method is invocated before the change
takes place and you may reject the change by returning -1. Returning 0
will do the parameter change and raise a @code{GLSIG_PARAM_CHANGED} signal
on the parameter.
@end deftypefn


Each filternode has a signal emitter associated to it through which all
of the signals from its sub-objects are re-emitted. So may want to add
signal handlers to the filters emitter. Currently there are two signals
that are passed along to the filter signal emitter. These are the
@code{GLSIG_PARAM_CHANGED} signal and the @code{GLSIG_PIPE_CHANGED} signal.

%% FIXME - describe what to do and not to do in those signal handlers




@node Doing Real Work, Working on SAMPLEs, Filter Methods, The Filter Programming API
@subsection Doing Real Work

Now what to do inside the @code{f()} method? Receiving, modifying, creating, and
forwarding streams of data which are grouped into buffers is the answer. 
This leads us to the filter buffer API. A filter buffer is obtained using 
one of the following functions:

@tindex filter_buffer_t
@tindex filter_node_t
@deftypefun {filter_buffer_t *} fbuf_alloc (int @var{size}, struct list_head *@var{list})
@code{fbuf_alloc()} will allocate a new buffer with space for @var{size}
bytes. The list parameter is to 
keep track of allocated buffers for cleanup after failures. You may want to
supply @code{&n->launch_context->buffers} for @var{list}.
This function can return @code{NULL} if the system is short on memory.
@end deftypefun

@tindex filter_buffer_t
@tindex filter_pipe_t
@deftypefun {filter_buffer_t *} fbuf_get (filter_pipe_t *@var{p})
@code{fbuf_get()} receives the next filter buffer from the specified input
pipe. It will return @code{NULL} at @code{EOF}. You have to forward the 
@code{EOF} mark. @code{fbuf_get()} copes with a @code{NULL} @var{p} by just
returning @code{NULL}.
@end deftypefun

All filter buffers are reference counted to allow zero-copy and copy-on-demand
operations. Both @code{fbuf_alloc()} and @code{fbuf_get()} will return with 
one reference of the
buffer held. To get additional references or to drop one reference use the
following functions:

@tindex filter_buffer_t
@deftypefun void fbuf_ref (filter_buffer_t *@var{fb})
@code{fbuf_ref()} will get you one additional reference. A reference will
protect the buffer from being modified and from being destroyed. Once
the reference count drops to zero, you may no longer access it or any
of its contents. @code{fbuf_ref()} does not copy the buffer. @code{fbuf_ref()}
ignores @code{NULL} @var{fb}s.
@end deftypefun

@tindex filter_buffer_t
@deftypefun void fbuf_unref (filter_buffer_t *@var{fb})
@code{fbuf_unref()} will drop one reference. See above for more about
references. @code{fbuf_unref} ignores @code{NULL} @var{fb}s.
@end deftypefun

To get information on a filter buffer and to access its contents, use the
following functions which are actually very fast macros:

@tindex filter_buffer_t
@deftypefun int fbuf_size (filter_buffer_t *@var{fb})
@code{fbuf_size()} returns the number of bytes in the filter buffer.
@code{fbuf_size()} returns 0 if @var{fb} is @code{NULL}.
@end deftypefun

@tindex filter_buffer_t
@deftypefun {char *} fbuf_buf (filter_buffer_t *@var{fb})
@code{fbuf_buf()} returns a pointer to the buffer's contents.
@end deftypefun

If you want to modify a buffer directly rather than reading from a received one
and storing into a freshly allocated one, you have to make the buffer private.
This additional requirement makes copy-on-demand and zero-copy possible. Use
@code{fbuf_make_private()}:

@tindex filter_buffer_t
@deftypefun {filter_buffer_t *} fbuf_make_private (filter_buffer_t *@var{fb})
@code{fbuf_make_private()} will return a private copy of the provided buffer
which you may modify. @code{fbuf_lock()} will not copy the buffer if you are the
sole user of the buffer, i.e. the reference count is one. For a @code{NULL}
@var{fb} @code{fbuf_mark_private()} returns @code{NULL}.
@end deftypefun

To forward a filter buffer you have to hold one reference for each output pipe
you send the buffer to. Buffer sending is done using the following function:

@tindex filter_pipe_t
@tindex filter_buffer_t
@deftypefun void fbuf_queue (filter_pipe_t *@var{p}, filter_buffer_t *@var{fb})
@code{fbuf_queue()} queues the specified filter buffer to the specified pipe.
One reference gets eaten by this operation. @code{fbuf_queue()} copes with
a @code{NULL} @var{p} by unref'ing @var{fb}.
@end deftypefun

For extended protocols on top of the @code{fbuf} API have a look into 
@ref{Working on SAMPLEs}.


@node Working on SAMPLEs, , Doing Real Work, The Filter Programming API
@subsection Working on SAMPLEs

There are two extended protocol defined at the moment. Those are the sbuf
protocol which is just a very simple @code{SAMPLE}-only 
transportation protocol with no fields in the header actually used and
the fft protocol which shares all properties with the sbuf protocol apart
from the pipe type and the pipe properties. 
So only the functions with parameters or semantics different from their
@code{fbuf_*} equivalents are listed here. As for the rest, you may assume that
wrappers exist with the appropriate @code{sbuf_*} name but the same parameters
and semantics as described in the @code{fbuf_*} sections.

@deftypefun {filter_buffer_t *} sbuf_alloc (int @var{size}, filter_node_t *@var{n})
@code{sbuf_alloc()} allocates a new buffer containing space for @var{size}
numbers
of @code{SAMPLE}s and assigns the buffer to the filter node @var{n}.
@end deftypefun
@deftypefun int sbuf_size (filter_buffer_t *@var{fb})
@code{sbuf_size()} returns the size of the buffer as number of @code{SAMPLE}s.
@end deftypefun
@deftypefun {SAMPLE *} sbuf_buf (filter_buffer_t *@var{fb})
@code{sbuf_buf()} returns a pointer to the buffer containing the @code{SAMPLE}s.
@end deftypefun




@node The Filter Network API, , The Filter Programming API, Filter API
@section The Filter Network API

The filter network API provides functions to construct and run arbitrary
networks of filters. This part of the filter API is intended to be used by the
high level part of the glame project, i.e. the console and the graphical user
interface. You can learn from the various test programs, too.

@menu
* Creating a Filter Network::
* Processing Data in a Network::
@end menu

@node Creating a Filter Network, Processing Data in a Network, , The Filter Network API
@subsection Creating a Filter Network

Constructing a network of filters is documented by referencing and
commenting the necessary functions to do so.

@tindex filter_node_t
@tindex filter_network_t
@deftypefun {filter_node_t *} filternetwork_add_node (filter_network_t *@var{net}, const char *@var{f}, const char *@var{name})
@code{filternetwork_add_node()} creates an instance of a filter with the
provided identifier @var{f} and adds it to the set of filters of the
specified filter network. The node is given the provided @var{name}, or a
unique one is chosen automatically if you pass @code{NULL}.
@code{filternetwork_add_node()} returns a handle to the instance of a filter,
a filter node, or @code{NULL}, if an error occured.
@end deftypefun

@tindex filter_network_t
@tindex filter_portdesc_t
@tindex filter_param_t
@deftypefun filter_portdesc_t* filternetwork_add_input (filter_network_t *@var{net}, const char *@var{node}, const char *@var{port}, const char *@var{label}, const char *@var{desc})
@deftypefunx filter_portdesc_t* filternetwork_add_output (filter_network_t *@var{net}, const char *@var{node}, const char *@var{port}, const char *@var{label}, const char *@var{desc})
@deftypefunx filter_param_t* filternetwork_add_param (filter_network_t *@var{net}, const char *@var{node}, const char *@var{param}, const char *@var{label}, const char *@var{desc})
These functions make internal ports and parameters identified by the
@var{node} and @var{port} or @var{param} labels visible to the outside
world of the filternetwork using the name @var{label} and the
description @var{desc}.
@end deftypefun


@node Processing Data in a Network, , Creating a Filter Network, The Filter Network API
@subsection Processing Data in a Network

To start processing data with a constructed filter the following
functions are provided:

@tindex filter_t
@deftypefun int filter_launch (filter_t *@var{net})
@code{filter_launch()} asynchronously starts the init phase of a
previously constructed filter using a set of filter threads.
@code{filter_launch()} returns -1 if there were any problems launching
the filter or 0 on success.  Errors in the initialisation
process of the filters' @code{f()} methods are not reported by
@code{filter_launch()} but can instead be obtained by using
@code{filter_wait()} or @code{filter_start()}. Processing of the data is
not started until @code{filter_start()} is called.
@end deftypefun

@tindex filter_t
@deftypefun int filter_start (filter_t *@var{net})
@deftypefunx int filter_pause (filter_t *@var{net})
With @code{filter_start()} you can start processing data on a previously
launched or paused filter. With @code{filter_pause()} you can
temporarily stop processing of any data in a previously started
filter. Both functions return -1 if any error occured in the process of
starting, pausing or in the filter threads.
@end deftypefun

@tindex filter_t
@deftypefun int filter_wait (filter_t *@var{net})
@code{filter_wait()} waits for a previously launched filter to
finish processing.  @code{filter_wait()} returns 0 if the filter
terminated regularly, and -1 if there were any errors, either in waiting
for the filter or in processing the filter.
@end deftypefun

@tindex filter_t
@deftypefun void filter_terminate (filter_t *@var{net})
@code{filter_terminate} kills a previously launched filter. It
doesn't wait for it to finish processing all data.
@end deftypefun




