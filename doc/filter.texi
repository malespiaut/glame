@comment $Id: filter.texi,v 1.14 2000/03/20 09:44:00 richi Exp $

@node Filter API, Filter Tutorial, Copying, Top
@chapter Filter API

@table @strong
@item NOTE
For a brief overview of the available functions and macros you may
look at the central @file{filter.h} headerfile.
The filter subsystem should have settled now. So you may expect
existing API functions and semantics not to change in the near future.

@item NOTE 2
This is not a guide on filter programming! Look for this in the filter
tutorial (@pxref{Filter Tutorial}).
@end table

The filter subsystem has three independent APIs, one for the filter registry,
one for filter programming and one for using the filters and connecting them
to so called filter networks.

If you have any questions related to this document, please quote the 
relevant lines and send your comments per e-mail to
@email{glame-devel@@glame.sourceforge.net} (c/o richi).

@menu
* Introducing the Filter Subsystem::
* Filter Initialisation::
* The Filter Registry API::
* The Filter Programming API::
* The Filter Network API::
@end menu

@node Introducing the Filter Subsystem, Filter Initialisation, , Filter API
@section Introducing the Filter Subsystem

The filter subsystem introduces the concepts of filters and networks of
filters. The basic idea is to have streams transporting arbitrary data
with attached properties floating through a network. This network comprises 
of so called @dfn{filter nodes} which are connected to each other through
@dfn{filter pipes}. The filter nodes may modify the data in the streams
and its properties. A filter node can even merge two or more streams into
one stream or split one stream into any number of streams containing the
same data and the same properties by reference.
To tune the operations on the stream each filter node may be assigned a
number of parameters. Each filter pipe can be assigned a number of parameters
at both ends, too.

From the API's point of view there are two classes of objects, the 
descriptors and
their instances. Descriptors in the filter subsystem are @code{filter_t},
@code{filter_portdesc_t} and @code{filter_paramdesc_t} with their corresponding
instances @code{filter_node_t}, @code{filter_pipe_t} and @code{filter_param_t}.
@code{filter_pipe_t} is a special case as a filter pipe is actually
an instance of two filter ports---it is a connection between these ports.

Not mentioned here is the @code{filter_network_t} instance. A filter network
is an instance of a @code{filter_t}, too. Think of it as an extension of a
filter node. This exchangability of filter nodes and filter networks and their
description as filters is one of the major features of the filter subsystem.
This means that you can set up a network of filters, and in turn convert this
filter network into an abstract filter which you can use in another filter
network by instantiating it.


@node Filter Initialisation, The Filter Registry API, Introducing the Filter Subsystem, Filter API
@section Filter Initialisation

The filter subsystem is initialized statically. To register available
filters you have to call @code{glame_init()} from the glame midlayer.


@node The Filter Registry API, The Filter Programming API, Filter Initialisation, Filter API
@section The Filter Registry API

The filter registry API is used by the filters to register themselves and by 
any external program which wants to get access to the filter names and their
descriptions. Note that the filter registry API is not necessarily thread
consistent.

@menu
* Defining Filter I/O::
* Finding Filters::
* Getting Filter Info::
@end menu

@node Defining Filter I/O, Finding Filters, , The Filter Registry API
@subsection Defining Filter I/O

To register itself, a new filter has to specify its supported input and output
ports and its optional parameters. The recommended order of
registration is the following: First, allocate a filter structure via
@code{filter_alloc()}. Second, in arbitrary order register all input ports via
@code{filter_add_input()}, all output ports via @code{filter_add_output()} 
and all parameters via @code{filter_add_param()}. Third, add port specific 
parameters to the input and output ports via @code{filterport_add_param()}.
Fourth, add the filter to the filter registry using @code{filter_add()}.

@tindex filter_t
@tindex filter_node_t
@deftypefun {filter_t *} filter_alloc (int (*@var{f})(filter_node_t *))
@code{filter_alloc()} will allocate a new filter structure.
The filter method will be set to the
provided function @code{@var{f}()} which is the only mandatory method for 
filters.
@code{filter_alloc()} returns a handle to the filter or @code{NULL} on error.
For the description of optional filter methods you can look at 
@ref{Filter Methods}.
@end deftypefun

@tindex filter_t
@deftypefun {filter_t *} filter_from_network (filter_network_t *@var{net})
@code{filter_from_network()} is another possibility to create a new filter.
Unlike @code{filter_alloc()} you get a full featured filter, including all
ports and parameters. You just have to add it to the database using 
@code{filter_add()}. Using this function you get the ability to turn a
complex filter network into an easily usable filter
(@pxref{Using Filter Networks as Filters}).
@end deftypefun

@tindex filter_portdesc_t
@tindex filter_t
@deftypefun {filter_portdesc_t *} filter_add_input (filter_t *@var{f}, const char *@var{label}, const char *@var{description}, int @var{type})
@tindex filter_portdesc_t
@tindex filter_t
@deftypefunx {filter_portdesc_t *} filter_add_output (filter_t *@var{f}, const char *@var{label}, const char *@var{description}, int @var{type})
@code{filter_add_input()} and @code{filter_add_output()} add an input or
output port respectively to filter @var{f} with the specified @var{label} 
and @var{description}.
@var{type} specifies the supported connection types as a
mask with the additional flag @code{FILTER_PORTTYPE_AUTOMATIC} which
specifies that the port will accept multiple connections to it. 
The currently supported port types are
@code{FILTER_PORTTYPE_SAMPLE}, @code{FILTER_PORTTYPE_RMS},
@code{FILTER_PORTTYPE_MISC} and @code{FILTER_PORTTYPE_ANY} which does
allow any type of input or output. @code{filter_add_input()} and
@code{filter_add_output()} will return the port description structure on
success and @code{NULL} on error.
@end deftypefun

@tindex filter_paramdesc_t
@tindex filter_t
@deftypefun {filter_paramdesc_t *} filter_add_param (filter_t *@var{f}, const char *@var{label}, const char *@var{description}, int @var{type})
@deftypefunx {filter_paramdesc_t *} filterport_add_param (filter_portdesc_t *@var{port}, const char *@var{label}, const char *@var{description}, int @var{type})
@code{filter_add_param()} adds a parameter with the specified @var{label} and
@var{description} to the filter. @code{filterport_add_param()} adds a parameter
to the specified port; parameter values can be set per connected pipe. 
@var{type} specifies the type of the parameter. The currently supported 
parameter types are 
@code{FILTER_PARAMTYPE_INT}, 
@code{FILTER_PARAMTYPE_FLOAT}, 
@code{FILTER_PARAMTYPE_SAMPLE},
@code{FILTER_PARAMTYPE_FILE} and @code{FILTER_PARAMTYPE_STRING}.
@code{filter_add_param()} and @code{filterport_add_param()} will return the
parameter description structure on
success and @code{NULL} on error.
@end deftypefun

@deftypefun void filter_delete_port (filter_t *@var{f}, filter_portdesc_t *@var{port})
@code{filter_delete_port()} will remove and destroy the specified port from
filter @var{f}.
@end deftypefun

@deftypefun void filter_delete_param (filter_t *@var{f}, filter_paramdesc_t *@var{param})
@code{filter_delete_param()} will remove and destroy the specified parameter 
from filter @var{f} or one of its ports.
@end deftypefun

@tindex filter_t
@deftypefun int filter_add (filter_t *@var{f}, const char *@var{name}, const char *@var{description})
@code{filter_add()} will add the filter to the registry using the specified
@var{name} and @var{description}. After adding
the filter you may not modify it, neither by adding additional inputs
or outputs, nor by adding parameters or changing their types.
@end deftypefun


@node Finding Filters, Getting Filter Info, Defining Filter I/O, The Filter Registry API
@subsection Finding Filters

To query a registered filter you can either directly query the filter by name
or walk through all registered filters. Both methods yield a handle to the
filter which you can access using the macros and functions described later on.

@tindex filter_t
@deftypefun {filter_t *} filter_get (char *@var{name})
@code{filter_get()} will return a handle to the filter with the
specified @var{name}, or @code{NULL} if no such filter is registered.
@end deftypefun

@tindex filter_t
@deftypefun {filter_t *} filter_next (filter_t *@var{f})
@code{filter_next()} walks through all available filters in the registry. To
get the first registered filter just supply @code{NULL} as the @var{f}
argument. Otherwise you get the next registered filter or @code{NULL}
if there are no more filters left.
@end deftypefun


@node Getting Filter Info, , Finding Filters, The Filter Registry API
@subsection Getting Filter Info

To query information about an existing filter like available parameters, output
or input ports the following functions can be used.
@emph{Remember that any structure returned by this functions is strictly 
read-only.}

@deftypefun {const char *} filter_name (filter_t *@var{f})
@deftypefunx {const char *} filter_description (filter_t *@var{f})
Using @code{filter_name()} and @code{filter_description()} you get access to
the filter's name and short description.
@end deftypefun

To access the filter's input and output ports and in turn query information
about them you should use the following functions.

@deftypefun int filter_nrinputs (filter_t *@var{f})
@deftypefunx int filter_nroutputs (filter_t *@var{f})
These functions return the number of input and output ports assigned to the
filter @var{f}.
@end deftypefun

@tindex filter_portdesc_t
@tindex filter_t
@deftypefun {filter_portdesc_t *} filter_get_inputdesc (filter_t *@var{f}, const char *@var{label})
@tindex filter_portdesc_t
@tindex filter_t
@deftypefunx {filter_portdesc_t *} filter_get_outputdesc (filter_t *@var{f}, const char *@var{label})
Using these functions you can query the filter about its input and output ports
by name. Both functions return a port description structure which you can access
using the later described functions, or @code{NULL} if there is no port with
the specified name.
@end deftypefun

@tindex filter_portdesc_t
@tindex filter_t
@deftypefn Iterator {} filter_foreach_inputdesc (filter_t *@var{f}, filter_portdesc_t *@var{d}) @{ @}
@tindex filter_portdesc_t
@tindex filter_t
@deftypefnx Iterator {} filter_foreach_outputdesc (filter_t *@var{f}, filter_portdesc_t *@var{d}) @{ @}
With these two iterators you can loop through all available ports of the
filter @var{f} just like in the @code{for} construct using @var{d} as running
variable.
@end deftypefn

To access information in the port description structure and query
existing port specific parameters you can use the following functions.

@deftypefun {const char *} filterportdesc_label (filter_portdesc_t *@var{d})
@deftypefunx {const char *} filterportdesc_description (filter_portdesc_t *@var{d})
@deftypefunx int filterportdesc_type (filter_portdesc_t *@var{d})
@code{filterportdesc_label()} and @code{filterportdesc_description()} return 
label or description of the port respectively. With 
@code{filterportdesc_type()} you can query the type mask of the pipes that are
allowed to connect.
@end deftypefun

@deftypefun int filterportdesc_nrparams (filter_portdesc_t *@var{d})
Using @code{filterportdesc_nrparams()} you can query the number of port specific
parameters of port @var{d}.
@end deftypefun

@deftypefun {filter_paramdesc_t *} filterportdesc_get_paramdesc (filter_portdesc_t *@var{d}, const char *@var{label})
With @code{filterportdesc_get_paramdesc()} you can query a port specific 
parameter by name just like you can do with @code{filter_get_paramdesc()}.
@end deftypefun

@deftypefn Iterator {} filterportdesc_foreach_paramdesc (filter_portdesc_t *@var{d}, filter_paramdesc_t *@var{p}) @{ @}
Using this iterator you can loop through all available port specific parameters
of port @var{d} similar to @code{filter_foreach_inputdesc}.
@end deftypefn

To query a filter about existing parameters the following functions do exist.

@deftypefun int filter_nrparams (filter_t *@var{f})
@code{filter_nrparams()} does return the number of parameters of filter
@code{@var{f}()}.
@end deftypefun

@tindex filter_paramdesc_t
@tindex filter_t
@deftypefun {filter_paramdesc_t *} filter_get_paramdesc (filter_t *@var{f}, const char *@var{label})
Use @code{filter_get_paramdesc()} to query a filter about an existing
parameter descriptor by name. @code{filter_get_paramdesc()} returns a parameter
descriptor or @code{NULL} if no parameter with the specified label exists.
@end deftypefun

@tindex filter_paramdesc_t
@tindex filter_t
@deftypefn Iterator {} filter_foreach_paramdesc (filter_t *@var{f}, filter_paramdesc_t *@var{d}) @{ @}
With the @code{filter_foreach_paramdesc} iterator you can loop through all
available parameter descriptors of a filter.
@end deftypefn

To access the various fields of the parameter description structure
the following functions should be used.

@deftypefun {const char *} filterparamdesc_label (filter_paramdesc_t *@var{d})
@deftypefunx {const char *} filterparamdesc_description (filter_paramdesc_t *@var{d})
These functions return label and description respectively of the parameter
described by the parameter descriptor @var{d}.
@end deftypefun

@deftypefun int filterparamdesc_type (filter_paramdesc_t *@var{d})
Using this function you can query a parameter descriptor about the type of
the parameter. See @code{filter_add_param()} for a list of available
parameter types.
@end deftypefun


@node The Filter Programming API, The Filter Network API,The Filter Registry API, Filter API
@section The Filter Programming API

The filter programming API consists of functions to receive, create and forward
buffers, of functions to access the connections made to the filters ports, and
of functions to get and set the filters parameters. The filter programming API
also defines the semantics of the methods provided by the filters itself as
they are used by the filter network API. The filter programming API is
designed to be thread safe.

@menu
* Filter Methods::
* Accessing Filter Ports and Parameters::
* Doing Real Work::
* Working on SAMPLEs::
@end menu

@node Filter Methods, Accessing Filter Ports and Parameters, , The Filter Programming API
@subsection Filter Methods

Let's start with defining the semantics of the methods a filter can provide.
All methods are stored in the 
@tindex filter_t
@code{filter_t} structure, but only the @code{f()} method is
mandatory. You have to set all other methods explicitly---sane defaults are
provided for them. To learn about semantic details you may want to look into
the file @file{src/filter/filter_network.c}, too.

@tindex filter_node_t
@deftypefn Method int f (filter_node_t *@var{n})
@code{f()} is the main method of every filter, it's the only mandatory method. 
@code{f()} does the filter work, i.e. it gets launched as thread once the
filter network starts operating. See below for what to do in this
method. You have to return -1 if you don't like anything of the setup,
which will terminate the whole network, or 0 if everything was ok and you
are finished with processing.

@findex FILTER_AFTER_INIT
@findex FILTER_DO_CLEANUP
@findex FILTER_BEFORE_CLEANUP
Required parts of the @code{f()} method are an initialization section which
must be ended by a call of the @code{FILTER_AFTER_INIT} macro and a cleanup
section which @code{FILTER_BEFORE_CLEANUP} has to precede. In the initialization
section you may not use any functions which may block on the network. You may
return -1 at any point during the initialization indicating an error. Once your
code hits @code{FILTER_AFTER_INIT}, returning 0 is mandatory though. In the
init section, use macro @code{FILTER_DO_CLEANUP} for a jump to the cleanup
section. 
For further advise see the @ref{Filter Tutorial}.
@end deftypefn

@tindex filter_node_t
@deftypefn Method int init (filter_node_t *@var{n})
@code{init()} gets called by the @code{filternetwork_add_node()} function after allocating a
new instance of a filter (the so called filternode). You may do
anything with the private field of the filternode, everything else is strictly
private. If you return -1 the node is deleted and @code{filternetwork_add_node()} will return an error. If everything is ok you should return 0.
@end deftypefn

@tindex filter_node_t
@tindex filter_pipe_t
@deftypefn Method int connect_out (filter_node_t *@var{source}, const char *@var{port}, filter_pipe_t *@var{p})
@code{connect_out()} is invoked by the @code{filternetwork_add_connection()} 
function.
@code{connect_out()} gets called at each connection request to an output port
but before the call to the @code{connect_in()} method of the corresponding
destination port. You may reject the connection by returning -1 or
accept it by returning 0. You should set up the pipe type and the
corresponding fields in the type-specific union using the appropriate macros.
You may modifiy the pipe's source, i.e. perform redirections---but be careful.
@end deftypefn

@tindex filter_node_t
@tindex filter_pipe_t
@deftypefn Method int connect_in (filter_node_t *@var{dest}, const char *@var{port}, filter_pipe_t *@var{p})
@code{connect_in()} is like @code{connect_out()} but gets called after the 
@code{connect_out()}
call, and you don't have to set up any type specific information in the
filter pipe @var{p}. Just return -1 if you don't like the connection. 
Otherwise return 0. Redirections of the destination may be done under the
same conditions as in @code{connect_out()}.
@end deftypefn

@tindex filter_node_t
@deftypefn Method int fixup_param (filter_node_t *@var{n}, filter_pipe_t *@var{p}, const char *@var{name}, filter_param_t *@var{param})
@code{fixup_param()} gets called by @code{filternode_set_param()} or
@code{filterpipe_set_*param()} if the @var{p} parameter is not @code{NULL}. 
Here you may accept or
reject a parameter change for the filter. Return -1 if you do not like
anything about the setup. You have to fix the pipe parameters of all
affected output ports. Returning -1 does not revert a parameter change. Use
@code{filternode_set_param()} and friends to correct wrong parameter values.
In this method you may break an existing connection
using @code{filternetwork_break_connection()}.
@end deftypefn

@tindex filter_node_t
@tindex filter_pipe_t
@deftypefn Method int fixup_pipe (filter_node_t *@var{n}, filter_pipe_t *@var{in})
@code{fixup_pipe()} gets called by @code{filternetwork_add_connection()} 
but can also be called by a source
filter to tell about changes in an input port's pipe.
In both cases you are required to adjust all affected output
pipes with respect to their types and parameters. You also have to
forward the fixup request to each changed pipe by calling its
destination's fixup method. Return -1 if anything is wrong with the setup, 
else return 0.
@end deftypefn

@tindex filter_node_t
@tindex filter_pipe_t
@deftypefn Method void fixup_break_in (filter_node_t *@var{n}, filter_pipe_t *@var{in})
@tindex filter_node_t
@tindex filter_pipe_t
@deftypefnx Method void fixup_break_out (filter_node_t *@var{n}, filter_pipe_t *@var{out})
@code{fixup_break_in()} and @code{fixup_break_out()} are called by all 
connection breaking functions. You are required to check the setup after the
breaking of a connection and do anything necessary to
return to a sane state. The provided pipes are disconnected already.
@end deftypefn



@node Accessing Filter Ports and Parameters, Doing Real Work, Filter Methods, The Filter Programming API
@subsection Accessing Filter Ports and Parameters

As important as the semantics of the filters methods are the functions through
which a filter can access the pipes connected to its input and output 
ports and the parameters at the filter node scope as well as at the pipe scope.
The description of these functions follow.

@deftypefun {const char *} filternode_name (filter_node_t *@var{n})
Using this function you get access to the name of the filternode @var{n}.
@end deftypefun

@deftypefun int filternode_nrinputs (filter_node_t *@var{n})
@deftypefunx int filternode_nroutputs (filter_node_t *@var{n})
These functions return the number of connections on the input and output ports.
@end deftypefun

@tindex filter_pipe_t
@tindex filter_node_t
@deftypefun {filter_pipe_t *} filternode_get_input (filter_node_t *@var{n}, const char *@var{label})
@tindex filter_pipe_t
@tindex filter_node_t
@deftypefunx {filter_pipe_t *} filternode_get_output (filter_node_t *@var{n}, const char *@var{label})
@tindex filter_pipe_t
@deftypefunx {filter_pipe_t *} filternode_next_input (filter_pipe_t *@var{p})
@tindex filter_pipe_t
@deftypefunx {filter_pipe_t *} filternode_next_output (filter_pipe_t *@var{p})
The @code{filternode_get_*()} functions provide you with access to the filter
node's connections on the specified input or output port by name. If there
is more than one connection on a port you may cycle through all connections
using the @code{filternode_next_*()} functions which
will return the next connection on the same port where
the first connection on the port was accessed using @code{filternode_get_*()}. 
This is useful for ports with the @code{FILTER_PORTTYPE_AUTOMATIC} flag 
set only.
@end deftypefun

@tindex filter_node_t
@tindex filter_pipe_t
@deftypefn Iterator {} filternode_foreach_input (filter_node_t *@var{n}, filter_pipe_t *@var{p}) @{ @}
@tindex filter_node_t
@tindex filter_pipe_t
@deftypefnx Iterator {} filternode_foreach_output (filter_node_t *@var{n}, filter_pipe_t *@var{p}) @{ @}
These programming structures loop through all connections on input or
output ports of the specified filter node.
This is especially useful for filters with only one input or output port
which additionally is of the type @code{FILTER_PORTTYPE_AUTOMATIC}. It acts
like the @code{for} construct, i.e. the parameter @var{p} is assigned 
the input or output pipe on each loop iteration.
@end deftypefn


@tindex filter_pipe_t
To access information contained in the @code{filter_pipe_t} structures returned
by the above functions, you may use the following functions. Also functions
to access the per-pipe-end parameters are described here.

@deftypefun int filterpipe_type (filter_pipe_t *@var{p})
@code{filterpipe_type()} will return the type of the pipe.
@end deftypefun


@findex connect_out
@findex fixup_param
To initialize a pipe inside the @code{connect_out()} or
@code{fixup_param()} method you should use one of the following
boilerplate functions. Also the per-pipe-type access methods you should
use are described here, grouped by pipe type.

@deftypefun void filterpipe_settype_sample (filter_pipe_t *@var{p}, int @var{rate}, float @var{hangle})
@tindex FILTER_PIPETYPE_SAMPLE
@deftypefunx int filterpipe_sample_rate (filter_pipe_t *@var{p})
@deftypefunx float filterpipe_sample_hangle (filter_pipe_t *@var{p})
@code{filterpipe_settype_sample()} sets the pipe type to
@code{FILTER_PIPETYPE_SAMPLE} and initializes the type specific
@code{rate} and @code{hangle} field to the value provided.
@code{filterpipe_sample_rate()} and @code{filterpipe_sample_hangle()}
return the pipes sample rate and its horizontal angle respectively.
@end deftypefun



@deftypefun {filter_param_t *} filterpipe_get_sourceparam (filter_pipe_t *@var{p}, const char *@var{label})
@deftypefunx {filter_param_t *} filterpipe_get_destparam (filter_pipe_t *@var{p}, const char *@var{label})
With these functions you get access to the set parameters on the source
or destination end of a pipe by name. These functions
will return @code{NULL} if either no such parameter does exist or it was never
set. @strong{DEPRECATED}
@end deftypefun

To get access to the parameters of a filter node and to access the information
contained inside the @code{filter_param_t} structure, the following functions
are provided.

@tindex filter_param_t
@tindex filter_node_t
@deftypefun {filter_param_t *} filternode_get_param (filter_node_t *@var{n}, const char *@var{label})
This function will provide you with access to a node's parameter by name.
@code{filternode_get_param()} will return a @code{filter_param_t} structure 
that you can access using the macros and functions described later on. 
This function will return @code{NULL} if either no such parameter does exist 
or it was never set.
@end deftypefun

@deftypefun int filterparam_val_int (filter_param_t *@var{p})
@deftypefunx float filterparam_val_float (filter_param_t *@var{p})
@deftypefunx fileid_t filterparam_val_file (filter_param_t *@var{p})
@deftypefunx SAMPLE filterparam_val_sample (filter_param_t *@var{p})
@deftypefunx {char *} filterparam_val_string (filter_param_t *@var{p})
These macros return the value of the parameter. You should use the macro
which corresponds to the parameter type (which you should know anyway or
you can obtain from the corresponding parameter descriptor structure).
@end deftypefun

@deftypefun {char *} filterparam_to_string (filter_param_t *@var{p})
@deftypefunx {void *} filterparamval_from_string (filter_paramdesc_t *@var{d}, const char *@var{val})
With these functions conversion between strings and parameters is supported.
Both functions return pointers to storage you have to @code{free()} 
on your own.
@end deftypefun


@node Doing Real Work, Working on SAMPLEs, Accessing Filter Ports and Parameters, The Filter Programming API
@subsection Doing Real Work

Now what to do inside the @code{f()} method? Receiving, modifying, creating, and
forwarding streams of data which are grouped into buffers is the answer. 
This leads us to the filter buffer API. A filter buffer is obtained using 
one of the following functions:

@tindex filter_buffer_t
@tindex filter_node_t
@deftypefun {filter_buffer_t *} fbuf_alloc (int @var{size}, struct list_head *@var{list})
@code{fbuf_alloc()} will allocate a new buffer with space for @var{size}
bytes. The list parameter is to 
keep track of allocated buffers for cleanup after failures. You may want to
supply @code{&n->launch_context->buffers} for @var{list}.
This function can return @code{NULL} if the system is short on memory.
@end deftypefun

@tindex filter_buffer_t
@tindex filter_pipe_t
@deftypefun {filter_buffer_t *} fbuf_get (filter_pipe_t *@var{p})
@code{fbuf_get()} receives the next filter buffer from the specified input
pipe. It will return @code{NULL} at @code{EOF}. You have to forward the 
@code{EOF} mark. @code{fbuf_get()} copes with a @code{NULL} @var{p} by just
returning @code{NULL}.
@end deftypefun

All filter buffers are reference counted to allow zero-copy and copy-on-demand
operations. Both @code{fbuf_alloc()} and @code{fbuf_get()} will return with 
one reference of the
buffer held. To get additional references or to drop one reference use the
following functions:

@tindex filter_buffer_t
@deftypefun void fbuf_ref (filter_buffer_t *@var{fb})
@code{fbuf_ref()} will get you one additional reference. A reference will
protect the buffer from being modified and from being destroyed. Once
the reference count drops to zero, you may no longer access it or any
of its contents. @code{fbuf_ref()} does not copy the buffer. @code{fbuf_ref()}
ignores @code{NULL} @var{fb}s.
@end deftypefun

@tindex filter_buffer_t
@deftypefun void fbuf_unref (filter_buffer_t *@var{fb})
@code{fbuf_unref()} will drop one reference. See above for more about
references. @code{fbuf_unref} ignores @code{NULL} @var{fb}s.
@end deftypefun

To get information on a filter buffer and to access its contents, use the
following functions which are actually very fast macros:

@tindex filter_buffer_t
@deftypefun int fbuf_size (filter_buffer_t *@var{fb})
@code{fbuf_size()} returns the number of bytes in the filter buffer.
@code{fbuf_size()} returns 0 if @var{fb} is @code{NULL}.
@end deftypefun

@tindex filter_buffer_t
@deftypefun {char *} fbuf_buf (filter_buffer_t *@var{fb})
@code{fbuf_buf()} returns a pointer to the buffer's contents.
@end deftypefun

If you want to modify a buffer directly rather than reading from a received one
and storing into a freshly allocated one, you have to make the buffer private.
This additional requirement makes copy-on-demand and zero-copy possible. Use
@code{fbuf_make_private()}:

@tindex filter_buffer_t
@deftypefun {filter_buffer_t *} fbuf_make_private (filter_buffer_t *@var{fb})
@code{fbuf_make_private()} will return a private copy of the provided buffer
which you may modify. @code{fbuf_lock()} will not copy the buffer if you are the
sole user of the buffer, i.e. the reference count is one. For a @code{NULL}
@var{fb} @code{fbuf_mark_private()} returns @code{NULL}.
@end deftypefun

To forward a filter buffer you have to hold one reference for each output pipe
you send the buffer to. Buffer sending is done using the following function:

@tindex filter_pipe_t
@tindex filter_buffer_t
@deftypefun void fbuf_queue (filter_pipe_t *@var{p}, filter_buffer_t *@var{fb})
@code{fbuf_queue()} queues the specified filter buffer to the specified pipe.
One reference gets eaten by this operation. @code{fbuf_queue()} copes with
a @code{NULL} @var{p} by unref'ing @var{fb}.
@end deftypefun

For extended protocols on top of the @code{fbuf} API have a look into 
@ref{Working on SAMPLEs}.


@node Working on SAMPLEs, , Doing Real Work, The Filter Programming API
@subsection Working on SAMPLEs

There is one extended protocol defined at the moment. This is the sbuf
protocol which is just a very simple @code{SAMPLE}-only 
transportation protocol with no fields in the header actually used. 
So only the functions with parameters or semantics different from their
@code{fbuf_*} equivalents are listed here. As for the rest, you may assume that
wrappers exist with the appropriate @code{sbuf_*} name but the same parameters
and semantics as described in the @code{fbuf_*} sections.

@deftypefun {filter_buffer_t *} sbuf_alloc (int @var{size}, filter_node_t *@var{n})
@code{sbuf_alloc()} allocates a new buffer containing space for @var{size}
numbers
of @code{SAMPLE}s and assigns the buffer to the filter node @var{n}.
@end deftypefun
@deftypefun int sbuf_size (filter_buffer_t *@var{fb})
@code{sbuf_size()} returns the size of the buffer as number of @code{SAMPLE}s.
@end deftypefun
@deftypefun {SAMPLE *} sbuf_buf (filter_buffer_t *@var{fb})
@code{sbuf_buf()} returns a pointer to the buffer containing the @code{SAMPLE}s.
@end deftypefun


@node The Filter Network API, , The Filter Programming API, Filter API
@section The Filter Network API

The filter network API provides functions to construct and run arbitrary
networks of filters. This part of the filter API is intended to be used by the
high level part of the glame project, i.e. the console and the graphical user
interface. You can learn from the various test programs, too.

@menu
* Creating a Filter Network::
* Processing Data in a Network::
* Using Filter Networks as Filters::
* Textual Representation of Filter Networks::
@end menu

@node Creating a Filter Network, Processing Data in a Network, , The Filter Network API
@subsection Creating a Filter Network

Constructing a network of filters is documented by referencing and
commenting the necessary functions to do so.

@tindex filter_network_t
@deftypefun {filter_network_t *} filternetwork_new ()
@code{filternetwork_new()} allocates and initializes a new filter network
descriptor to which subsequent filters can be added. Connections 
between those filters can be established.
@code{filternetwork_new()} returns a handle to the new filter network or 
@code{NULL} if an error occured.
@end deftypefun

@tindex filter_network_t
@deftypefun void filternetwork_delete (filter_network_t *@var{net})
@code{filternetwork_delete()} deletes the filter network and all its contained
filter nodes.
@end deftypefun

@deftypefun int filternetwork_nrnodes (filter_network_t *@var{net})
@deftypefunx {filter_node_t *} filternetwork_get_node (filter_network_t *@var{net}, const char *@var{name})
With these functions you can query the number of nodes in the network and
get access to them by name.
@end deftypefun

@deftypefn Iterator {} filternetwork_foreach_node (filter_network_t *@var{net}, filter_node_t *@var{node}) @{ @}
This iterator loops through all nodes in the network.
@end deftypefn


@tindex filter_node_t
@tindex filter_network_t
@deftypefun {filter_node_t *} filternetwork_add_node (filter_network_t *@var{net}, const char *@var{f}, const char *@var{name})
@code{filternetwork_add_node()} creates an instance of a filter with the
provided identifier @var{f} and adds it to the set of filters of the
specified filter network. The node is given the provided @var{name}, or a
unique one is chosen automatically if you pass @code{NULL}.
@code{filternetwork_add_node()} returns a handle to the instance of a filter,
a filter node, or @code{NULL}, if an error occured.
@end deftypefun

@tindex filter_node_t
@deftypefun void filternode_delete (filter_node_t *@var{node})
@code{filternode_delete()} deletes the filter node and breaks all established
connections and deletes all set parameters.
@end deftypefun

@tindex filter_pipe_t
@tindex filter_node_t
@deftypefun {filter_pipe_t *} filternetwork_add_connection (filter_node_t *@var{source}, const char *@var{source_port}, filter_node_t *@var{dest}, const char *@var{dest_port})
@code{filternetwork_add_connection()} connects two filter nodes by using 
the output port specified as @var{source_port} and the input port 
specified as @var{dest_port}.
@code{filternode_add_connection()} returns the internal representation 
of the connection, a filter pipe on success or @code{NULL} if any party
disliked the connection.
@end deftypefun

@tindex filter_pipe_t
@deftypefun void filternetwork_break_connection (filter_pipe_t *@var{p})
@code{filternetwork_break_connection()} breaks a previously established
connection. Note that upon breakage some
filter nodes may decide to break additional connections to return
to a sane state of the network.
@end deftypefun

@tindex filter_node_t
@deftypefun int filternode_set_param (filter_node_t *@var{n}, const char *@var{label}, void *@var{val})
@code{filternode_set_param()} sets the parameter with the specified @var{label}
of the filter node @var{n} to the value pointed to by @var{val}. 
The type of the value
pointed to can be obtained by the @code{filter_get_paramdesc()} function
operating on the filter of the filter node.
@code{filternode_set_param()} returns 0 on success or -1 if the
set or change operation is not possible or causes any problems in the network.
@end deftypefun

@deftypefun int filterpipe_set_sourceparam (filter_pipe_t *@var{p}, const char *@var{label}, void *@var{val})
@deftypefunx int filterpipe_set_destparam (filter_pipe_t *@var{p}, const char *@var{label}, void *@var{val})
With these functions you can set the per-pipe-end parameters just like you
can set parameters using @code{filternode_set_param}. @strong{DEPRECATED}
@end deftypefun



@node Processing Data in a Network, Using Filter Networks as Filters, Creating a Filter Network, The Filter Network API
@subsection Processing Data in a Network

To start processing data with a constructed network the following functions are
provided:

@tindex filter_network_t
@deftypefun int filternetwork_launch (filter_network_t *@var{net})
@code{filternetwork_launch()} asynchronously starts the init phase of a 
previously constructed filter network using a set of filter threads.
@code{filternetwork_launch()} returns -1 if there were any problems launching
the filter network or 0 on success.
Errors in the initialisation process of the filters' @code{f()} methods are not
reported by @code{filternetwork_launch()} but can instead be obtained by using
@code{filternetwork_wait()} or @code{filternetwork_start()}. Processing of
the data is not started until @code{filternetwork_start()} is called.
@end deftypefun

@tindex filter_network_t
@deftypefun int filternetwork_start (filter_network_t *@var{net})
@deftypefunx int filternetwork_pause (filter_network_t *@var{net})
With @code{filternetwork_start()} you can start processing data on a
previously launched or paused network. With @code{filternetwork_pause()}
you can temporarily stop processing of any data in a previously started
network. Both functions return -1 if any error occured in the process of
starting, pausing or in the network threads.
@end deftypefun

@tindex filter_network_t
@deftypefun int filternetwork_wait (filter_network_t *@var{net})
@code{filternetwork_wait()} waits for a previously launched filter network to
finish processing.
@code{filternetwork_wait()} returns 0 if the filter network terminated
regularly, and -1 if there were any errors, either in waiting for the
network or in processing the network.
@end deftypefun

@tindex filter_network_t
@deftypefun void filternetwork_terminate (filter_network_t *@var{net})
@code{filternetwork_terminate} kills a previously launched filter network. It
doesn't wait for it to finish processing all data.
@end deftypefun


@node Using Filter Networks as Filters, Textual Representation of Filter Networks, Processing Data in a Network, The Filter Network API
@subsection Using Filter Networks as Filters

To save a filter network and reuse it as regular filter the following
functions are provided:

@tindex filter_network_t
@deftypefun {char *} filternetwork_to_string (filter_network_t *@var{net})
@code{filternetwork_to_string()} saves the current state of the filter
network into a string and returns a pointer to it. NULL is returned on
error. You have to @code{free()} the returned string later.
@end deftypefun


@node Textual Representation of Filter Networks, , Using Filter Networks as Filters, The Filter Network API
@subsection Textual Representation of Filter Networks

@strong{NOTE!} this is now more part of the glame midlayer, only the
@code{filternetwork_to_string()} function is here which generates
executable scheme code.

