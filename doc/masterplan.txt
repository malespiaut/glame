GLAME - Masterplan

[This file started out as an all-German document. It was translated to English 
later on to accomodate further developers. The original version can be found
in meisterplan_de.txt.]

This document is a collection of random thoughts, ideas and basic design 
decisions. It's ordered roughly chronologically. We try not to delete stuff in
here but rather comment on it. Thus earlier comments may be outdated or 
superceded by later stuff (or by code that someone started to implement
without bothering with the Masterplan).

Features
 - Channels in glame resemble the layers in gimp, i.e. a channel is just
   one channel with an assigned offset and length.
   
 - Channels carry a type ('left', 'right', 'centre', 'misc', etc.)
   Q: And what if I'd like to have more than your four? [m]
   A: etc. is not a type, just add what you think is necessary. Besides,
   there's no-one enforcing a type to exist only once! [richi]

 - Bookmarks et al. will be fully supported by making use of an additional,
   datafile independent file in XML format.

 - We're likely to need our own file format.

 - Internally, anything works on a 'swapfile'. This swapfile offers a notion
   of 'files' representing one 'channel' (see above) each. 

 - The swapfile modifies files via insert/delete transactions, which yields
   a possible 'undo' feature. Several transactions can be grouped with
   begin/end markers. 'Undo' then undoes the whole set of transactions.
   
 - What audiofile readers have to do is to simply populate the swapfile. 
   Writers have to read it back and generate the desired format.

 - Filters work on one or more streams (audio streams or something else).
   A filter network may be built from several filters. Filter operations
   within this network perform 'realtime'.
 
 - Those really wicked filters that prove to be non-realtime capable may work
   straight on swapfile's files as an alternative.



Sample code for swapfile
========================

Read in a one-channel audio file, but without a channel, just the raw 
part for swapfile.h: [Pardon??? -Editor]
--------------------

f = file_alloc(filesize);
pos = 0;
do {
  fc = filecluster_get(f, pos);
  mem = filecluster_mmap(fc);
  memcpy(mem, filedata + pos, filecluster_size(fc));
  filecluster_munmap(fc);
  pos+=filecluster_size(fc);
} while (pos < filesize);



Write back an audio file, same restrictions as above. File-id is known
(in f) (just like above, simply without file_alloc):
----------------------------------------------------

pos = 0;
do {
  fc = filecluster_get(f, pos);
  mem = filecluster_mmap(fc);
  write(fd, mem, filecluster_size(fc));
  filecluster_munmap(fc);
  pos += filecluster_size(fc);
} while (pos < size);


A filter reading and modifying region between pos1 and pos2 in a file
associated to id f:
-------------------


df = file_alloc(pos2-pos1);

pos = pos1;
do {
  /* ok, das hier ist ficken :) - zwei ineinandergeschachtelte
   * files muessen gemmappt werden - das schreit nach einem
   * wrapper a-la map_part(f1, f2, pos, &size) */
  /* Translation: ok, that's ficken :) - two intertwinded files have to
   * be mapped - crying out for a map_part(f1, f2, pos, &size)-like wrapper
   */
} while (pos < pos2);

file_transaction_begin(f);
file_unref(file_op_delete(f, pos1, pos2-pos1));
file_op_insert(f, pos1, df);
file_transaction_end(f);






Q&A regarding swapfile & co.
============================

Q: I don't quite get this swap_t thingie. Do we have just one swapfile or many?
A: We have just one swapfile with a fixed divine size.

Q: I understand we have a static swap node pointing to all swapfiles. Any
   open audio file needs a swapfile. And these are kept in a list. That's all
   that's supposed to be in swapfile anyway. Each swapfile consists of
   clusters. Any audiofile reader is supposed to generate a swapfile with
   n clusters for n channels.
A: The swapfile only has a notion of logical units 'file' (usually a 'file'
   will represent one channel of an audio stream).

Q: Meta data and raw data within the same file?
A: Swapfile and the 'file's in swapfile hold raw data only. Any meta data has
   to be kept seperately.

Q: fid is used to map an operation to a cluster?
A: fid describes a 'file' (a whole channel). Every operation works on one or
   more 'file's.

Q: Are the log entries stored in the swapfile aside the clusters? I'd guess
   they aren't. If they were, that would make it much easier to continue
   working on old data after the program went haywire.
A: Syntax Error. (Transaction log and cluster lists are stored at the
   beginning of the swapfile.)

Q: ?
A: see irclog.#gtrax, irclog.#glame, etc.



maggy's audiofile layer plan:
-----------------------------

With richi's implementation of swapfile as the base layer, it might be a good
idea to implement the layers above:

  - glame manages arbitrary numbers of audio files.
  - An audio file comprises of a collection of channels.
  - A channel keeps raw data (swapfile->file) and additional information:
    * length of channel in bytes
    * frequency in bytes per second
    That's all I can think of right now as audio file internally is always 
    32bit. Anything else depends on the format chosen at save time:
    * bytes per second
    * mono/stereo
    * bits per sample
    etc.

I imagine audiofile management similar to richi's file management in
swapfile.c. I'll try to design a similar API.

!!!!
API/all info should be kept in sync with filter API (cf. filter/filter.h,
filter_t, stream_info_t) [richi]
!!!!



richi's and Belbo's filter plan:
================================
(editied to suit filter/*)

Filters can be displayed in a graph, i.e. any node (filter) may contain
 - arbitrary numbers of input streams
 - arbitrary numbers of output streams
 - arbitrary numbers of parameters (with defaults).

Each node within the graph is represented by a thread. Streams are
data packets that get their address transferred through a pipe from node to
node. Streams can be generated or destroyed anywhere in the graph. It's
possible to split the data stream without copying. As a data stream may be
modified it gets copied automatically when appropriate.

The following filters are already implemented:
 - drop:	destroy any number of input streams
 - one2n:	'copy' an input stream to n output streams
 - mix:		mix any number of input streams to one output stream
 - file_in:	generate a swapfile file from an input stream
 - file_out:	generate an output stream from a swapfile file

Furthermore the following filters exist for debugging:
 - null:	forward any number of input streams to corresponding output
 		streams without touching the data at all
 - ping:	generate an output stream and expect it back as an input
   		stream which may be routed along an arbitrary path. ping
		measures the latency via this path.

And the following filter examples:
 - dup:		duplicate an input stream (one2n supercedes this)
 - volume_adjust:
 		scale the samples of an input stream by a fixed factor.

Further filters someone ought to implement:
 - delay:	prepend zeros or discard the beginning
 - shorten:	discard the end
 - esd:		data output via esd
 - etc. [FIXME]

Filters have to work 'locally' (i.e. almost sequentially) on the data. Stream
packets have arbitrary size but there may be more than one packet in a single
node (buffering of short sequences of packets).

More info on this topic can be found in the (as always extensively commented)
header files and the sample filters.

Those filter allow a natural implementation of a mixing desk (preferably
completely interactive with XWolf's GUI... :))



Representation of a filter network in Scheme (RFC)
==================================================

(let ((foo (file_out '("blubb")))
      (bar (file_out '("puff")))
     )
     ((let ((foobar (mix '(foo bar))))
	   ((file_in '("foobar" '(foobar)))
	    (esd '(foobar))
           )
      )
     )
)

... which mixes swapfile files 'blubb' and 'puff'. The result is output via
esd and also stored into file 'foobar'.
