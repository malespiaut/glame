
Features
 - Channels sind wie Layers im Gimp, d.h. ein Channel
   ist "ein Channel" mit Offset und Laenge
   
 - Die Channels haben einen Typ ("links", "rechts", "center", "misc", etc.)
   Q: und was is wenn ich mehr als deine vier haben will? [m]
   A: etc. is kein typ, man ergaenze halt entsprechend, ausserdem
      sagt ja niemand, dass ein typ nur einmal existieren darf [richi]
   
 - Dookmarks, u.ae. wird alles supported, dafuer gibts datenfile-unabhaengig
   ein XML-Format in einer extra Datei
 - Ausserdem brauchen wir wohl ein eigenes Dateiformat

 - Intern arbeitet alles auf einem "Swapfile", dieses Swapfile stellt
   "Files" zur Verfuegung die jeweils einen "Channel" (s.o.) darstellen
 - Das Swapfile arbeitet mit Transactions (insert/delete) auf den Files,
   d.h. ein Undo ist hierueber moeglich. Mehrere Transactions koennen
   mit begin/end markiert werden, Undo macht dann eine ganze Menge
   von Operationen rueckgaengig
   
 - Alle Audiofile-Reader muessen nur dieses Swapfile populaten,
   die Writer muessen es auslesen und das gewuenschte Format erzeugen

 - Filter arbeiten auf einem oder mehreren Streams (das koennen Audio-
   Streams sein, aber auch was anderes), aus mehreren Filtern kann
   ein Filter-Netzwerk gestrickt werden. Die Filteroperation auf diesem
   Netzwerk laufen "real-time" ab.

 - Andere, total komplizierte Filter (also nicht real-time faehige),
   koennen alternativ direkt auf den "Files" des "Swapfile" arbeiten





Beispielkot fuer swapfile:
==========================

ein audiofile einlesen, mit nur einem channel, aber ohne channel, nur
den raw-teil fuer swapfile.h:
-------------------------------

f = file_alloc(filesize);
pos = 0;
do {
  fc = filecluster_get(f, pos);
  mem = filecluster_mmap(fc);
  memcpy(mem, filedata + pos, filecluster_size(fc));
  filecluster_munmap(fc);
  pos+=filecluster_size(fc);
} while (pos < filesize);



ein audiofile schreiben, gleiche einschraenkung wie oben, file-id ist
bekannt (in f) (also genauso wie oben, nur ohne file_alloc):
-------------------------------------------------------------

pos = 0;
do {
  fc = filecluster_get(f, pos);
  mem = filecluster_mmap(fc);
  write(fd, mem, filecluster_size(fc));
  filecluster_munmap(fc);
  pos += filecluster_size(fc);
} while (pos < size);



ein filter, der die region pos1 bis pos2 liest und veraendert, das ganze
auf file mit id f:
--------------------


df = file_alloc(pos2-pos1);

pos = pos1;
do {
  /* ok, das hier ist ficken :) - zwei ineinandergeschachtelte
   * files muessen gemmappt werden - das schreit nach einem
   * wrapper a-la map_part(f1, f2, pos, &size) */
} while (pos < pos2);

file_transaction_begin(f);
file_unref(file_op_delete(f, pos1, pos2-pos1));
file_op_insert(f, pos1, df);
file_transaction_end(f);






Q&A zu Swapfile und Co.
=======================

Q: swap_t leucht mir nicht ganz ein. Haben wir nun ein swapfile oder viele ?
A: wir haben nur ein swapfile, das swapfile hat eine konstante von gott
   gegebene groesse

Q: So wie ich das sehe haben wir einen statischen swap node und der sollte auf
   alle swapfiles zeigen. Jedes offene audiofile braucht ein swapfile.
   Und die werden in ner Liste verwaltet. Was anderes sollte in swap gar
   nicht drin sein. Jedes swapfile besteht aus clustern. Jeder audiofile
   reader sollte dann ein swapfile mit n clustern fuer n channel generieren.
A: im swapfile gibts nur die logischen einheiten "file" (in der Regel
   entspricht ein "file" einem Channel eines Audio-Streams)

Q: Meta data und raw data im gleichen File?
A: Swapfile und die "file"s im Swapfile sind nur fuer die raw-daten da,
   eventuelle Meta-daten muessen extra gespeichert werden

Q: fid dient dazu ne op nem cluster zuzuordnen?
A: fid bezeichnet ein "file" (einen ganzen Channel), die Operationen
   arbeiten alle auf einem oder mehreren "files"

Q: Werden die logentries im swapfile gespeichert oder nur die Cluster? Ich
   schaetze mal letzteres. Ersteres wuerde es einfacher machen an alten daten
   weiterzuarbeiten, wenn das Programm abkackt.
A: Syntax Error. (der transaction-log und die cluster-listen sind am Anfang
   des Swapfiles gespeichert)

Q: ?
A: see irclog.#gtrax, irclog.#glame, etc.



maggy's audiofile layer plan:
-----------------------------

Nachdem richi nun swapfile als base layer implementiert hat, ist es wohl
notwendig das layer drueber zu implementieren:

  - glame verwaltet beliebig viele audiofiles.
  - Ein Audiofile besteht aus Ansammlung von channeln.
  - Ein Channel enthaelt rawdaten(swapfile->file) und zusaetzliche
    Informationen:
      - Channellaenge in bytes
      - Frequenz in bytes per second
    mehr faellt mir gar nicht ein, da das Audiofile intern 32bit is, alles
    andere is vom jeweiligen Format abhaengig das beim speichern gewaehlt
    wird:
      - Bytes per second
      - mono/stereo
      - bits per sample
      etc.

Die Verwaltung der audiofiles stell ich mir so aehnlich vor wie richis
verwaltung der Files in swapfile.c
Ich versuch einfach das API so aehnlich zu gestalten.

!!!!
das API/die ganzen Infos sollten irgendwie mit dem API fuer die filter
(s. filter/filter.h, filter_t, stream_info_t) koordiniert werden [richi]
!!!!



richi's and Belbo's filter plan:
================================
(ueberarbeitet, damit alles filter/* entspricht)

Filter koennen in einem Graphen angeordnet werden,
d.h. jeder Knoten (also Filter) kann
 - beliebig viele input-streams haben
 - beliebig viele output-streams haben
 - beliebig viele parameter (mit default-Werten) haben

Jeder Knoten im Graphen wird durch einen eigenen Thread
repraesentiert. Die "Streams" sind Datenpakete, deren Adresse ueber
Pipes von Knoten zu Knoten durchgereicht werden. Streams koennen
an jeder Stelle im Graphen erzeugt und vernichtet werden, ein
Aufteilen des Datenstroms ohne ihn zu kopieren ist moeglich.
Der Datenstrom kann modifiziert werden, bei Bedarf wird er hierzu
automatisch kopiert.

Bereits implementiert sind die folgenden Filter:
 - drop:  vernichtet beliebig viele Input-Streams
 - one2n: "kopiert" eine Input-Stream beliebig oft auf n
          Output-Streams
 - mix:   Mischt beliebig viele Input-Streams zu einem
	  Output-Stream
 - file_in: Erzeugt aus einem Input-Stream ein Swapfile File.
 - file_out: Erzeugt aus einem Swapfile File einen Output-Stream.

Ausserdem folgende Filter zu Debugging-Zwecken:
 - null:  Forwarded beliebig viele Input-Streams zu beliebig
          vielen korrespondierenden Output-Streams ohne
          etwas zu tun
 - ping:  Erzeugt einen Output-Stream und erwartet diesen
          ueber einen beliebigen Weg zurueck als Input-Stream,
          ping misst dabei die Latenz auf diesem Weg

Und folgende Beispiel-Filter:
 - dup:   dupliziert einen Input-Stream (one2n kann mehr)
 - volume_adjust: multipliziert die Samples eines Input-Streams
	  mit einem Faktor

Weitere Filter, die mal jemand implementieren koennte:
 - delay: 0'en Vorausschicken oder den Anfang wegschmeissen
 - shorten: das Ende wegschmeissen
 - esd:   Output der Daten ueber den esd
 - etc. [FIXME]


Filter muessen "lokal" (also fast sequentiell) auf den
Daten arbeiten, die Stream-Pakete sind unterschiedlich gross,
es koennen aber mehrere Pakete in einer Node sein (Buffern
kurzer Sequenzen von Paketen).

Mehr Infos gibts in den (wie immer ausfuehrlich kommentierten)
Header-Files und den Beispiel-Filtern.


Mit diesen Filtern koennen wir geschickt ein Mischpult
zusammenbasteln (am besten total interaktiv mit nem GUI
von XWolf... :))



Repraesentation eines Filter-Netzwerks mit Scheme (RFC)
=======================================================

(let ((foo (file_out '("blubb")))
      (bar (file_out '("puff")))
     )
     ((let ((foobar (mix '(foo bar))))
	   ((file_in '("foobar" '(foobar)))
	    (esd '(foobar))
           )
      )
     )
)

Was die swapfile files "blubb" und "puff" zusammenmixt
und das ergebnis sowohl ueber esd als auch in das
file "foobar" ausgibt.
