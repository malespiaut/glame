@comment $Id: swapfile.texi,v 1.1 2000/02/05 00:01:53 nold Exp $

@node Swapfile API, , Filter API, Top
@chapter Swapfile API

@table @strong
@item NOTE 
Do not read the source! You will probably not understand a
thing what is happening - you may even get blind! You have been
warned. 

@item NOTE 2 
Though the code is not easy to read, the API will not change until
after release 1.0
@end table

If you have any questions related to the covered (or uncovered but
related) topics in this document, please quote the questionable part of 
this document and send the questions per e-mail to 
@email{glame-devel@@glame.sourceforge.net} (c/o richi). If you have 
write access
to the source of this documentation, please insert lines like ``Q: I don't
understand what you mean by read-only.'' 

@menu
* Introduction::		Musings on swapfile philosophy
* Programming Interface::	Detailed description of swapfile API
@end menu

@node Introduction, Programming Interface, , Swapfile API
@section Introduction

This is the documentation for the swapfile subsystem of GNU/Linux Audio
Mechanics (@acronym{GLAME}). Swapfile was designed not specifically for 
@acronym{GLAME} but with
the idea of storing of and operating on audio streams.

Swapfile provides a store for multiple independend sets of (not necessarily)
one-dimensional data. Swapfile supports transparent and unlimited undo and 
redo of cut- and insert-like operations.

A set of data in swapfile is generally referred to as a @dfn{file}. Each such 
file is internally split up into so called @dfn{fileclusters} which determine 
the granularity of access to the files' contents.

A file can be in two states, which results from the fact that not all
operations on a file are logged, i.e. can be undone and redone. The two states
are basically read-only and read-write. On a file in read-only state you may
only start logged operations, on a read-write file you may do everything. The
states get switched as soon as there are pending or finished logged operations
on the file.

While this may sound like terribly lowering the use of swapfile, it greatly
simplifies and speeds up operations and reduces necessary storage by an 
incredible amount.

@node Programming Interface, , Introduction, Swapfile API
@section Programming Interface

So let's jump into listing the functions of the swapfile API and
document the semantics.

@menu
* Initialisation::
* File management::
* Accessing file data::
* Logged operations::
* Misc operations::
@end menu

@node Initialisation, File management, , Programming Interface
@subsection Initialisation

To initialize the swapfile subsystem you have to open an existing swapfile
which in turn you may create using the 
@command{gmkswap} utility. After finishing
operation you should close it again. Use the following functions:

@table @code
@anchor{swap_open}
@item int swap_open(char *name, int flags)

@code{swap_open()} opens the swapfile with the specified name and 
the specified
flags (no flags are defined yet, use 0). Returns -1 if it was not
possible to open the swapfile or the swapfile is in an inconsistent
state.

@anchor{swap_close}
@item void swap_close()

@code{swap_close()} closes the swapfile and updates the metadata state of the
on-disk version of the swapfile. This puts the swapfile into a consistent
state.
@end table

@node File management, Accessing file data, Initialisation, Programming Interface
@subsection File management

To allocate and free files in a swapfile there exist two functions---well
actually there are three, but the last one is less generic as it will turn your
file into read-only state.

@table @code
@anchor{file_alloc}
@item fileid_t file_alloc(off_t size)

@code{file_alloc()} allocates a new file of the provided size. 
The return value
is a handle for all subsequent operations on the file, -1 is returned on
error. The contents of the file are initially set to zero and its state
will be read-write after the operation.

@anchor{file_unref}
@item void file_unref(fileid_t fid)

@code{file_unref()} drops the file identified with @code{fid} and all 
its data. This
operation is not logged and in turn cannot be undone. @code{file_unref()} 
accepts files in both states, read-only and read-write.

Another set of two functions lets you change and query the size of a file.

@anchor{file_truncate}
@item int file_truncate(fileid_t fid, off_t size)

@code{file_truncate()} takes a file in read-write state and truncates 
its size to
@code{size}, just like the @code{ftruncate()} call does with regular 
unix-files.
If @code{size} is less than the current size of the file, all data after and
including position @code{size} will be discarded.
If @code{size} is greater than the current size of the file, subsequently
allocated data is initially set to zero.
@code{file_truncate()} is not logged, i.e. you cannot undo this operation. The
state of the file does not change from read-write. @code{file_truncate()}
will return 0 on success or -1 on error, in which case file is not modified at
all.

@anchor{file_size}
@item off_t file_size(fileid_t fid)

@code{file_size()} returns the size of file identified with @code{fid} 
or -1 if no such
file exists. The state of the file does not matter, neither is it changed
by @code{file_size()}. The file itself of course remains unchanged as well.

As mentioned above, there is another way to create a new file. This is by
copying an existing file or a part of it.

@anchor{file_copy}
@item fileid_t file_copy(fileid_t fid, off_t pos, off_t size)

@code{file_copy()} will generate a new file containing the contents 
in the interval
[@code{pos}, @code{pos}+@code{size}[ of the old file as 
@emph{reference}---i.e. no additional
storage is required for this operation. This has the downside that both
files, the source and the destination are switched to state read-only
(the initial state of the source file does not matter).
The identifier of the duplicate is returned, or -1 on error. It is illegal to
specify an interval not entirely contained in the source file.
@end table

@node Accessing file data, Logged operations, File management, Programming Interface
@subsection Accessing file data

The following operations allow direct access to the files' data either for
reading (read-only state) or reading and writing (read-write state). All access
passes through fileclusters (@pxref{Introduction}). To access parts of the 
file data,
you first have to get the corresponding filecluster, then @code{mmap()} 
it and finally munmap it. The functions are

@table @code

@anchor{filecluster_get}
@item filecluster_t *filecluster_get(fileid_t fid, off_t pos)

@code{filecluster_get()} will return the filecluster containing the 
position @code{pos} of
the file identified with @code{fid}. It is illegal to specify a 
position outside
of the file or an unexisting one, @code{NULL} is returned in these cases.

@anchor{filecluster_start}
@item filecluster_start(filecluster_t *fc)
@anchor{filecluster_end}
@item filecluster_end(filecluster_t *fc)
@anchor{filecluster_size}
@item filecluster_size(filecluster_t *fc)

@code{filecluster_start} returns the position of the first contained datum,
@code{filecluster_end} returns the position of the last contained datum and
@code{filecluster_size} will return the size of the contained data in bytes.

@anchor{filecluster_next}
@item filecluster_next(fc)
@anchor{filecluster_prev}
@item filecluster_prev(fc)

@code{filecluster_next} and @code{filecluster_prev} let you traverse the 
fileclusters of a file. Both may return @code{NULL} if you hit the start or 
the end of the file. The first filecluster of a file always satisfies
@code{filecluster_start(fc) == 0}, the last filecluster of a 
file satisfies
@code{filecluster_end(fc) == file_size(fid)} and each pair of adjacent
fileclusters satisfies 
@code{filecluster_end(prev)+1 == filecluster_start(next)}.

@anchor{filecluster_mmap}
@item char *filecluster_mmap(filecluster_t *fc)

@code{filecluster_mmap()} will @code{mmap()} the data contained in 
the filecluster and
return a pointer to it. The @code{mmapp()}ed memory area is 
write-protected, if the
file of the filecluster is in read-only state (so you will get a 
@code{SIGSEGV}
if you try to write into it). Note that it is illegal to access parts of
the @code{mmapp()ed} area not within the filecluster's size. Caveat emptor!
@code{filecluster_mmap()} may change the size of the filecluster! 
So if you want to have access to position @code{pos} in file @code{f},
you may have to do

@example
@group
fc = filecluster_get(f, pos);
mem = filecluster_mmap(fc);
while (pos > filecluster_end(fc)) @{
        filecluster_munmap(fc);
        fc = filecluster_next(fc);
        mem = filecluster_mmap(fc);
@}
@end group
@end example 

@anchor{filecluster_munmap}
@item void filecluster_munmap(filecluster_t *fc)

@code{munmap()}s a previously @code{mmap()}ped filecluster. It is 
illegal to @code{munmap()} a filecluster more times than it has been 
@code{mmap()}ped.
@end table

@node Logged operations, Misc operations, Accessing file data, Programming Interface
@subsection Logged operations

Now for the @dfn{logged operations}. 
All those operations have to be grouped into a
@dfn{transaction} of one or more operations. 
Such a transaction can be undone and
subsequently redone.

@table @code

To start and end a transaction you have to use the following two functions:

@anchor{file_transaction_begin}
@item int file_transaction_begin(fileid_t fid)
@anchor{file_transaction_end}
@item int file_transaction_end(fileid_t fid)

@code{file_transaction_begin()} will start a new transaction for the file 
@code{fid},
@code{file_transaction_end()} will end it. Nested @code{begin}/@code{end} 
calls are allowed. Both operations return 0 on success and -1 on error.

@anchor{file_transaction_undo}
@item int file_transaction_undo(fileid_t fid)
@anchor{file_transaction_redo}
@item int file_transaction_redo(fileid_t fid)

@code{file_transaction_undo()} will try to undo the last completed 
transaction of the file @code{fid}, @code{file_transaction_redo()} will try 
to redo the last undone
transaction of the file. It is illegal to undo a transaction currently in
progress; you have to end it first. Note that all redo-records of a file
are discarded once you begin a new transaction on this file.

The operations that can be undone and redone are the following ones---you may
miss some operations commonly used, but you may notice that you can compose 
any standard operation with the following two logged operations and the (not
logged!) operation @code{file_copy()} (@pxref{file_copy}).

@anchor{file_op_insert}
@item int file_op_insert(fileid_t fid, off_t pos, fileid_t file)

@code{file_op_insert()} will insert the file @code{file} into the file 
@code{fid} at position
@code{pos}. @code{pos} has to be in the range of [0..@code{file_size(fid)}], 
else the operation fails. Both files will change their state to read-only, 
and you may not any longer access the inserted file @code{file}---all 
subsequent operations on it will fail and set @var{errno} to @code{ENOENT}. 
If this operation is undone, the
inserted file will become accessible again.
@code{file_op_insert()} will return 0 on success and -1 on error.

@anchor{file_op_cut}
@item int file_op_cut(fileid_t fid, off_t pos, off_t size)

@code{file_op_cut()} will cut the interval 
[@code{pos}..@code{pos}+@code{size}[ out of file @code{fid}.
The interval has to be entirely contained in @code{fid}. The file will change
its state to read-only.
@code{file_op_cut()} will return 0 on success and -1 on error.

The common cut&paste operations can be composed as follows:

@table @dfn
@item copy
@code{file_copy()}
@item paste 
@code{file_op_insert()} or @code{file_copy()} and @code{file_op_insert()} 
for multiple pastes
@item cut
@code{file_copy()} and @code{file_op_cut()}
@item delete 
@code{file_op_cut()}
@end table
@end table

@node Misc operations, , Logged operations, Programming Interface
@subsection Misc operations

@table @code
The semantics of the following function are not yet fully defined, it was 
added to support the @command{swapfile_info} tool.

@anchor{file_next}
@item fileid_t file_next(fileid_t fid)

@code{file_next()} will return the next file identifier after @code{fid}, 
or the first one if @code{fid} is -1. -1 is returned if no further file 
does exist. Be careful! At the moment you do not get a valid reference to 
the file, i.e. you may not operate on it in any way! So this function is 
essentially useless at the moment.
@end table

