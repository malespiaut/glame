@comment $Id: swapfile.texi,v 1.3 2000/02/07 12:55:40 nold Exp $

@node Swapfile API, Function and Type Index, Filter Tutorial, Top
@chapter Swapfile API

@table @strong
@item NOTE 
Do not read the source! You will probably not understand a
thing what is happening - you may even get blind! You have been
warned. 

@item NOTE 2 
Though the code is not easy to read, the API will not change until
after release 1.0
@end table

If you have any questions related to the covered (or uncovered but
related) topics in this document, please quote the questionable part of 
this document and send the questions per e-mail to 
@email{glame-devel@@glame.sourceforge.net} (c/o richi).

@menu
* Introduction::		Musings on swapfile philosophy
* Programming Interface::	Detailed description of swapfile API
@end menu

@node Introduction, Programming Interface, , Swapfile API
@section Introduction

This is the documentation for the swapfile subsystem of GNU/Linux Audio
Mechanics (GLAME). Swapfile was designed not specifically for 
GLAME but with
the idea of storing of and operating on audio streams.

Swapfile provides a store for multiple independent sets of (not necessarily)
one-dimensional data. Swapfile supports transparent and unlimited undo and 
redo of cut- and insert-like operations.

A set of data in swapfile is generally referred to as a @dfn{file}. Each such 
file is internally split up into so called @dfn{fileclusters} which determine 
the granularity of access to the files' contents.

A file can be in two states, which results from the fact that not all
operations on a file are logged, i.e. can be undone and redone. The two states
are basically read-only and read-write. On a file in read-only state you may
only start logged operations, on a read-write file you may do everything. The
states get switched as soon as there are pending or finished logged operations
on the file.

While this may sound like terribly lowering the use of swapfile, it greatly
simplifies and speeds up operations and reduces necessary storage by an 
incredible amount.

@node Programming Interface, , Introduction, Swapfile API
@section Programming Interface

So let's jump into listing the functions of the swapfile API and
document the semantics.

@menu
* Initialisation::
* File management::
* Accessing file data::
* Logged operations::
* Misc operations::
@end menu

@node Initialisation, File management, , Programming Interface
@subsection Initialisation

To initialize the swapfile subsystem you have to open an existing swapfile
which in turn you may create using the 
@file{gmkswap} utility. After finishing
operation you should close it again. Use the following functions:

@deftypefun int swap_open (char *@var{name}, int @var{flags})

@code{swap_open()} opens the swapfile with the specified @var{name} and 
the specified
@var{flags} (no flags are defined yet, use 0). Returns -1 if it was not
possible to open the swapfile or the swapfile is in an inconsistent
state.
@end deftypefun

@deftypefun void swap_close (void)

@code{swap_close()} closes the swapfile and updates the metadata state of the
on-disk version of the swapfile. This puts the swapfile into a consistent
state.
@end deftypefun

@node File management, Accessing file data, Initialisation, Programming Interface
@subsection File management

To allocate and free files in a swapfile there exist two functions---well
actually there are three, but the last one is less generic as it will turn your
file into read-only state.

@tindex fileid_t
@tindex off_t
@deftypefun fileid_t file_alloc (off_t @var{size})

@code{file_alloc()} allocates a new file of the provided @var{size}. 
The return value
is a handle for all subsequent operations on the file, -1 is returned on
error. The contents of the file are initially set to zero and its state
will be read-write after the operation.
@end deftypefun

@tindex fileid_t
@deftypefun void file_unref (fileid_t @var{fid})
@code{file_unref()} drops the file identified with @var{fid} and all 
its data. This
operation is not logged and in turn cannot be undone. @code{file_unref()} 
accepts files in both states, read-only and read-write.
@end deftypefun

Another set of two functions lets you change and query the size of a file.

@tindex fileid_t
@tindex off_t
@deftypefun int file_truncate (fileid_t @var{fid}, off_t @var{size})
@code{file_truncate()} takes a file in read-write state and truncates 
its size to
@var{size}, just like the @code{ftruncate()} call does with regular 
unix-files.
If @var{size} is less than the current size of the file, all data after and
including position @var{size} will be discarded.
If @var{size} is greater than the current size of the file, subsequently
allocated data is initially set to zero.
@code{file_truncate()} is not logged, i.e. you cannot undo this operation. The
state of the file does not change from read-write. @code{file_truncate()}
will return 0 on success or -1 on error, in which case file is not modified at
all.
@end deftypefun

@tindex off_t
@tindex fileid_t
@deftypefun off_t file_size (fileid_t @var{fid})

@code{file_size()} returns the size of file identified with @var{fid} 
or -1 if no such
file exists. The state of the file does not matter, neither is it changed
by @code{file_size()}. The file itself of course remains unchanged as well.
@end deftypefun

As mentioned above, there is another way to create a new file. This is by
copying an existing file or a part of it.

@tindex fileid_t
@tindex off_t
@deftypefun fileid_t file_copy (fileid_t @var{fid}, off_t @var{pos}, off_t @var{size})
@code{file_copy()} will generate a new file containing the contents 
in the interval
[@var{pos}, @var{pos}+@var{size}[ of the old file as 
@emph{reference}---i.e. no additional
storage is required for this operation. This has the downside that both
files, the source and the destination are switched to state read-only
(the initial state of the source file does not matter).
The identifier of the duplicate is returned, or -1 on error. It is illegal to
specify an interval not entirely contained in the source file.
@end deftypefun

@node Accessing file data, Logged operations, File management, Programming Interface
@subsection Accessing file data

The following operations allow direct access to the files' data either for
reading (read-only state) or reading and writing (read-write state). All access
passes through fileclusters (@pxref{Introduction}). To access parts of the 
file data,
you first have to get the corresponding filecluster, then @code{mmap()} 
it and finally @code{munmap()} it. The functions are

@tindex filecluster_t
@tindex fileid_t
@tindex off_t
@deftypefun {filecluster_t *} filecluster_get (fileid_t @var{fid}, off_t @var{pos})
@code{filecluster_get()} will return the filecluster containing the 
position @var{pos} of
the file identified with @var{fid}. It is illegal to specify a 
position outside
of the file or an unexisting one, @code{NULL} is returned in these cases.
@end deftypefun

@tindex off_t
@tindex filecluster_t
@deftypefn Macro off_t filecluster_start (filecluster_t *@var{fc})
@deftypefnx Macro off_t filecluster_end (filecluster_t *@var{fc})
@deftypefnx Macro off_t filecluster_size (filecluster_t *@var{fc})

@code{filecluster_start()} returns the position of the first contained datum,
@code{filecluster_end()} returns the position of the last contained datum and
@code{filecluster_size()} will return the size of the contained data in bytes.
@end deftypefn

@tindex filecluster_t
@deftypefn Macro {filecluster_t *} filecluster_next (filecluster_t *@var{fc})
@deftypefnx Macro {filecluster_t *} filecluster_prev (filecluster_t *@var{fc})

@code{filecluster_next()} and @code{filecluster_prev()} let you traverse the 
fileclusters of a file. Both may return @code{NULL} if you hit the start or 
the end of the file. The first filecluster of a file always satisfies
@code{filecluster_start(@var{fc}) == 0}, the last filecluster of a 
file satisfies
@code{filecluster_end(@var{fc}) == file_size(@var{fid})} and each pair of adjacent
fileclusters satisfies 
@code{filecluster_end(@var{prev})+1 == filecluster_start(@var{next})}.
@end deftypefn

@tindex filecluster_t
@deftypefun {char *} filecluster_mmap (filecluster_t *@var{fc})
@code{filecluster_mmap()} will @code{mmap()} the data contained in 
the filecluster and
return a pointer to it. The @code{mmapp()}ed memory area is 
write-protected, if the
file of the filecluster is in read-only state (so you will get a 
@code{SIGSEGV}
if you try to write into it). Note that it is illegal to access parts of
the @code{mmapp()ed} area not within the filecluster's size. Caveat emptor!
@code{filecluster_mmap()} may change the size of the filecluster! 
So if you want to have access to position @var{pos} in file @var{f},
you may have to do

@example
@group
@var{fc} = filecluster_get(@var{f}, @var{pos});
@var{mem} = filecluster_mmap(@var{fc});
while (@var{pos} > filecluster_end(@var{fc})) @{
        filecluster_munmap(@var{fc});
        @var{fc} = filecluster_next(@var{fc});
        @var{mem} = filecluster_mmap(@var{fc});
@}
@end group
@end example 
@end deftypefun

@tindex filecluster_t
@deftypefun void filecluster_munmap (filecluster_t *@var{fc})
@code{munmap()}s a previously @code{mmap()}ped filecluster. It is 
illegal to @code{munmap()} a filecluster more times than it has been 
@code{mmap()}ped.
@end deftypefun

@node Logged operations, Misc operations, Accessing file data, Programming Interface
@subsection Logged operations

Now for the @dfn{logged operations}. 
All those operations have to be grouped into a
@dfn{transaction} of one or more operations. 
Such a transaction can be undone and
subsequently redone.

To start and end a transaction you have to use the following two functions:

@tindex fileid_t
@deftypefun int file_transaction_begin (fileid_t @var{fid})
@deftypefunx int file_transaction_end (fileid_t @var{fid})
@code{file_transaction_begin()} will start a new transaction for the file 
@var{fid},
@code{file_transaction_end()} will end it. Nested @code{begin}/@code{end} 
calls are allowed. Both operations return 0 on success and -1 on error.
@end deftypefun

@tindex fileid_t
@deftypefun int file_transaction_undo (fileid_t @var{fid})
@deftypefunx int file_transaction_redo (fileid_t @var{fid})
@code{file_transaction_undo()} will try to undo the last completed 
transaction of the file @var{fid}, @code{file_transaction_redo()} will try 
to redo the last undone
transaction of the file. It is illegal to undo a transaction currently in
progress; you have to end it first. Note that all redo-records of a file
are discarded once you begin a new transaction on this file.
@end deftypefun

The operations that can be undone and redone are the following ones---you may
miss some operations commonly used, but you may notice that you can compose 
any standard operation with the following two logged operations and the (not
logged!) operation @code{file_copy()}.

@tindex fileid_t
@tindex off_t
@deftypefun int file_op_insert (fileid_t @var{fid}, off_t @var{pos}, fileid_t @var{file})
@code{file_op_insert()} will insert the file @var{file} into the file 
@var{fid} at position
@var{pos}. @var{pos} has to be in the range of [0, @code{file_size(@var{fid})}], 
else the operation fails. Both files will change their state to read-only, 
and you may not any longer access the inserted file @var{file}---all 
subsequent operations on it will fail and set @code{errno} to @code{ENOENT}. 
If this operation is undone, the
inserted file will become accessible again.
@code{file_op_insert()} will return 0 on success and -1 on error.
@end deftypefun

@tindex fileid_t
@tindex off_t
@deftypefun int file_op_cut (fileid_t @var{fid}, off_t @var{pos}, off_t @var{size})
@code{file_op_cut()} will cut the interval 
[@var{pos}, @var{pos}+@var{size}[ out of file @var{fid}.
The interval has to be entirely contained in @var{fid}. The file will change
its state to read-only.
@code{file_op_cut()} will return 0 on success and -1 on error.
@end deftypefun

@noindent
The common cut&paste operations can be composed as follows:

@table @dfn
@item copy
@code{file_copy()}
@item paste 
@code{file_op_insert()}, or @code{file_copy()} and @code{file_op_insert()} 
for multiple pastes
@item cut
@code{file_copy()} and @code{file_op_cut()}
@item delete 
@code{file_op_cut()}
@end table

@node Misc operations, , Logged operations, Programming Interface
@subsection Misc operations

The semantics of the following function are not yet fully defined, it was 
added to support the @file{swapfile_info} tool.

@tindex fileid_t
@deftypefun fileid_t file_next (fileid_t @var{fid})

@code{file_next()} will return the next file identifier after @var{fid}, 
or the first one if @var{fid} is -1. -1 is returned if no further file 
does exist. Be careful! At the moment you do not get a valid reference to 
the file, i.e. you may not operate on it in any way! So this function is 
essentially useless at the moment.
@end deftypefun

