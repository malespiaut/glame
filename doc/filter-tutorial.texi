@comment $Id: filter-tutorial.texi,v 1.5 2000/02/17 13:32:59 richi Exp $

@node Filter Tutorial, Swapfile API, Filter API, Top
@chapter Filter Tutorial

This document is about how to write filters for glame. It only covers
audio in/audio out types of filters. 

@menu
* Parameter Definition::	Talking about parameters, properties and protocols...
* Filter Categories::		Now what is this whole filter stuff anyway?
* Filter Skeleton::		What do I need to have in a glame filter set?
* Main Filter Method::		How does the @code{f()} function have to look like?
* Examples::                    Examples to clarify the @code{fbuf_*()} API
* Speeeed::                     How to optimize processing
@end menu

@node Parameter Definition, Filter Categories, , Filter Tutorial
@heading Talking about parameters, properties and protocols...
FIXME - rewrite this section

When talking about filters in the following sections, we'll make use of
various flavours of @dfn{parameters}.

First there are @dfn{input 
parameters} and @dfn{output parameters}, attached to the properties of the
filter's input and output pipes respectively. To summarize both groups of
parameters, we'll use the notion of @dfn{pipe parameters}. Sampling rate is
probably the most common example of a pipe parameter.

Some filters export hooks to dynamically tune their internal behaviour. We'll
refer to the associated values as @dfn{filter parameters}. Examples of typical
filter parameters are the delay time of an echo filter, or the gain values
of a mixing filter.

@node Filter Categories, Filter Skeleton, Parameter Definition, Filter Tutorial
@heading Now what is this whole filter stuff anyway?
In GLAME there are four different kinds of filters. For each you have to care
about different methods to ensure correct operation. The first three
share (by definition) the following property: they all use nothing
but SAMPLEs as their inputs/outputs.

So to begin with the fourth kind of filter, the one operating on types
different from SAMPLE as well. For this kind
you may need to implement every method in the filter struct. If you
want to implement such a complex filter, contact 
@email{glame-devel@@lists.sourceforge.net}
for advise.

@findex connect_out
@findex fixup_param
The first kind of filters summarizes those which have no input at all. 
I.e. this is
the class of @dfn{generators}. Generators have to ensure that the pipes
connected to them are assigned the correct type and type parameters.
Therefore they all need to provide the @code{connect_out()} method. If they
do have filter parameters which affect the output type/parameters, they also
have to provide the @code{fixup_param()} method. An example for this class
of filters is the sine filter in @file{waveform.c} as is the 
@code{read_file()} filter in @file{read_file.c}.

The second kind of filters comprises of those which have no output. 
I.e. this is the class of @dfn{sinks}. Sinks don't have to care about 
all that much. Everything they
need to setup can be done in the main filter method. So usually those
filters do not provide another method apart from @code{f()}. An example for
this class of filters is the @code{audio_out()} filter in 
@file{audio_io.c}.

@findex connect_out
@findex fixup_param
@findex fixup_pipe
The third kind of filters are the inbetween filters which require connected
input and output channels. I.e. these are the @dfn{true filters}. True 
filters have to provide a @code{connect_out()} method, if they may change 
any of the pipe parameters (i.e. what comes out is different from 
what comes in, like in a resample case). They also have to provide the 
@code{fixup_param()}
and the @code{fixup_pipe()} methods if there are dependencies between the
filter parameters and the output parameters or between the input 
parameters and the output parameters (different from a one-to-one mapping).

@node Filter Skeleton, Main Filter Method, Filter Categories, Filter Tutorial
@heading What do I need to have in a glame filter set?
You will need the following functions and methods:
@table @code
@findex filtersetname_register
@item filtersetname_register()
A filter registering function of the name @code{filtersetname_register()} 
which returns 0 on success and -1 on any error.
@findex f
@item f() 
The main filter method @code{f()}. You need this for each filter contained
in the filter set.
@item other filter methods
You may need to include other filter specific methods, too.
@end table

@findex f
@node Main Filter Method, Examples, Filter Skeleton, Filter Tutorial
@heading How does the @code{f()} function have to look like? Are there any restrictions?
Yes of course! There are!

@code{f()} should begin with checking the current setup for suitability,
i.e. look at the parameters and input types/formats. And it should set up
all necessary local things. @emph{After} this initialisation the macro
@findex FILTER_AFTER_INIT
@code{FILTER_AFTER_INIT;} has to appear! 
Before this macro you may simply return -1
to denote an error, returning with no error is not allowed.
After @code{FILTER_AFTER_INIT;} you should do the actual filter work, i.e.
accept and send data through the ports.
The main part of the filter and the cleanup part (freeing of all
local allocated data, etc.) have to be seperated by placing the macro 
@findex FILTER_BEFORE_CLEANUP
@code{FILTER_BEFORE_CLEANUP;}.
Neither in the main part, nor in the cleanup part may you just return with
a return value of -1 (i.e. just fail). Instead you have to cleanup yourself,
including sending @code{EOF}s to your output ports. So basically you may fail
in the initialisation part, but nowhere else.

@strong{You may not use any of the @code{?buf_*()}
functions in the @code{INIT} section (DEADLOCK!!!)} 
(@code{?buf_alloc()} is allowed, if you really need it)

Another section primitive is the @code{FILTER_CHECK_STOP;} macro which you
should use inside all operating loops to check for external stop or pause
queries. The corresponding cleanup section after @code{FILTER_BEFORE_STOPCLEANUP;}
is jumped to if any request has to be fulified.


For more complex filters which require some sort of backlog of sample
data or which do modify an input stream the following issues have to
be cared about:

You should not allocate a ringbuffer or backlog storage via malloc,
neither should you simply copy the data - this is not necessary - in
fact it is completely broken. You should instead just keep all the
fbuf's around that you need later (of course ref'ing and unref'ing them
at the appropriate time)

@findex fbuf_alloc
@findex sbuf_make_private
If your filter in priciple would support in-place read-modify-write of
the data you should not allocate new buffers for the output using
@code{fbuf_alloc()}. Instead you should grab the source buffer and do a
@code{sbuf_make_private()} on it taking the pointer returned from this as the
``new'' input buffer which you may modifiy now and later queue as
output.

@findex fbuf_alloc
@findex fbuf_make_private
If you do any modification of any buffer (including those which you just
allocated privately using @code{fbuf_alloc()} or friends) 
you must get the write-enabled buffer by calling @code{fbuf_make_private()}
and use the return value as the buffer to be written to!



@node Examples, Speeeed, Main Filter Method, Filter Tutorial
@subsection Examples

To clarify the reference counting and locking issues, in the following several
valid and invalid example uses of the API are given.

Valid just-forward buffers from input to output:
@example 
@group
@findex fbuf_get
@findex fbuf_queue
buf = fbuf_get(in);
fbuf_queue(out, buf);
@end group
@end example
@noindent
This is valid because @code{fbuf_get()} will get us a reference on the filter
buffer and @code{fbuf_queue()} eats it, i.e. the reference gets forwarded, too.

Invalid attempt to forward a buffer to two outputs:
@example
@group
@findex fbuf_get
@findex fbuf_queue
buf = fbuf_get(in);
fbuf_queue(out1, buf);
fbuf_queue(out2, buf);
@end group
@end example
@noindent
This is invalid because you don't have any reference left after the
first @code{fbuf_queue()}, i.e. there is no reference you can forward to the
second @code{fbuf_queue()}.

Valid but possibly ineffective just-forwarding:
@example
@group
@findex fbuf_get
@findex fbuf_ref
@findex fbuf_queue
@findex fbuf_unref
buf = fbuf_get(in);
fbuf_ref(buf);
fbuf_queue(out, buf);
fbuf_unref(buf);
@end group
@end example
@noindent
While being valid, this example illustrates ineffective use of references.
As you don't need to touch the buffer after @code{fbuf_queue()}, 
you don't need to get an additional reference and neither need to drop it again. 
Such use will cause a @code{fbuf_make_private()} in the destination filter to 
potentially copy the buffer while a perfectly valid zero-copy 
operation was possible.

Invalid modifying and forwarding of a buffer:
@example
@group
@findex fbuf_get
@findex fbuf_ref
@findex fbuf_buf
@findex fbuf_unref
@findex fbuf_queue
buf = fbuf_get(in);
fbuf_ref(buf);
fbuf_buf(buf)[0] = 1;
fbuf_unref(buf);
fbuf_queue(out, buf);
@end group
@end example
@noindent
This is invalid as the additional @code{fbuf_ref()} does not provide you with
a private modifable buffer, but just ensures that nobody else does
write to or destroy the buffer (which one can't anyway as you are 
holding a reference already---the one gotten by @code{fbuf_get()}).
The correct solution is to do:
@example
@group
@findex fbuf_get
@findex fbuf_make_private
@findex fbuf_buf
@findex fbuf_queue
buf = fbuf_get(in);
buf = fbuf_make_private(buf);
fbuf_buf(buf)[0] = 1;
fbuf_queue(out, buf);
@end group
@end example



@node Speeeed, , Examples, Filter Tutorial
@subsection Speeeed

FIXME - this section still needs to be written. Topics: constructing efficient
loops, using the streaming macros.
